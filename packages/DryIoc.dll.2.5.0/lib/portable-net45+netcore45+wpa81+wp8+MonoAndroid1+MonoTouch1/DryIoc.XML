<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DryIoc</name>
    </assembly>
    <members>
        <member name="T:DryIoc.Container">
            <summary>IoC Container. Documentation is available at https://bitbucket.org/dadhi/dryioc. </summary>
        </member>
        <member name="M:DryIoc.Container.#ctor">
            <summary>Creates new container with default rules <see cref="F:DryIoc.Rules.Default"/>.</summary>
        </member>
        <member name="M:DryIoc.Container.#ctor(DryIoc.Rules,DryIoc.IScopeContext)">
            <summary>Creates new container, optionally providing <see cref="P:DryIoc.Container.Rules"/> to modify default container behavior.</summary>
            <param name="rules">(optional) Rules to modify container default resolution behavior. 
            If not specified, then <see cref="F:DryIoc.Rules.Default"/> will be used.</param>
            <param name="scopeContext">(optional) Scope context to use for <see cref="F:DryIoc.Reuse.InCurrentScope"/>, default is <see cref="T:DryIoc.ThreadScopeContext"/>.</param>
        </member>
        <member name="M:DryIoc.Container.#ctor(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Creates new container with configured rules.</summary>
            <param name="configure">Delegate gets <see cref="F:DryIoc.Rules.Default"/> as input and may return configured rules.</param>
            <param name="scopeContext">(optional) Scope context to use for <see cref="F:DryIoc.Reuse.InCurrentScope"/>, default is <see cref="T:DryIoc.ThreadScopeContext"/>.</param>
        </member>
        <member name="M:DryIoc.Container.ToString">
            <summary>Outputs scope info for open scope.</summary> <returns>Info about scoped container</returns>
        </member>
        <member name="M:DryIoc.Container.With(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Shares all of container state except Cache and specifies new rules.</summary>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param> 
            <param name="scopeContext">(optional) New scope context, if not specified then uses context from current container.</param>
            <returns>New container.</returns>
        </member>
        <member name="M:DryIoc.Container.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional) Controls what to do with the next registration: ignore or throw exception.
            Throws exception by default.</param>
            <returns>New container preserving all current container state but disallowing registrations.</returns>
        </member>
        <member name="M:DryIoc.Container.WithoutCache">
            <summary>Returns new container with all expression, delegate, items cache removed/reset.
            It will preserve resolved services in Singleton/Current scope.</summary>
            <returns>New container with empty cache.</returns>
        </member>
        <member name="M:DryIoc.Container.WithoutSingletonsAndCache">
            <summary>Creates new container with state shared with original except singletons and cache.
            Dropping cache is required because singletons are cached in resolution state.</summary>
            <returns>New container with empty Singleton Scope.</returns>
        </member>
        <member name="M:DryIoc.Container.WithRegistrationsCopy(System.Boolean)">
            <summary>Shares all parts with original container But copies registration, so the new registration
            won't be visible in original. Registrations include decorators and wrappers as well.</summary>
            <param name="preserveCache">(optional) If set preserves cache if you know what to do.</param>
            <returns>New container with copy of all registrations.</returns>
        </member>
        <member name="P:DryIoc.Container.ScopeContext">
            <summary>Returns ambient scope context associated with container.</summary>
        </member>
        <member name="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})">
            <summary>Creates new container with new opened scope, with shared registrations, singletons and resolutions cache.
            If container uses ambient scope context, then this method sets new opened scope as current scope in the context.
            In case of previous open scope, new open scope references old one as a parent.
            </summary>
            <param name="name">(optional) Name for opened scope to allow reuse to identify the scope.</param>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param> 
            <returns>New container with different current scope.</returns>
            <example><code lang="cs"><![CDATA[
            using (var scoped = container.OpenScope())
            {
                var handler = scoped.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
        </member>
        <member name="F:DryIoc.Container.NonAmbientRootScopeName">
            <summary>The default name of root scope without ambient context.</summary>
        </member>
        <member name="M:DryIoc.Container.CreateFacade">
            <summary>Creates container (facade) that fallbacks to this container for unresolved services.
            Facade is the new empty container, with the same rules and scope context as current container. 
            It could be used for instance to create Test facade over original container with replacing some services with test ones.</summary>
            <remarks>Singletons from container are not reused by facade - when you resolve singleton directly from parent and then ask for it from child, it will return another object.
            To achieve that you may use <see cref="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/> with <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</remarks>
            <returns>New facade container.</returns>
        </member>
        <member name="M:DryIoc.Container.Dispose">
            <summary>Dispose either open scope, or container with singletons, if no scope opened.</summary>
        </member>
        <member name="F:DryIoc.Container.StateParamExpr">
            <summary>State parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.Container.ResolverContextParamExpr">
            <summary>Resolver context parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.Container.ResolverExpr">
            <summary>Resolver parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.Container.ScopesExpr">
            <summary>Access to scopes in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.Container.ResolutionScopeParamExpr">
            <summary>Resolution scope parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="M:DryIoc.Container.GetStateItemExpression(System.Int32)">
            <summary>Creates state item access expression given item index.
            State items actually are singleton items. So that method knows about Singleton items structure.</summary>
            <param name="itemIndex">Index of item.</param>
            <returns>Expression.</returns>
        </member>
        <member name="M:DryIoc.Container.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.</summary>
            <returns>Existing registrations.</returns>
            <remarks>Decorator and Wrapper types are not included.</remarks>
        </member>
        <member name="M:DryIoc.Container.Register(DryIoc.Factory,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean)">
            <summary>Stores factory into container using <paramref name="serviceType"/> and <paramref name="serviceKey"/> as key
            for later lookup.</summary>
            <param name="factory">Any subtypes of <see cref="T:DryIoc.Factory"/>.</param>
            <param name="serviceType">Type of service to resolve later.</param>
            <param name="serviceKey">(optional) Service key of any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>
            implemented.</param>
            <param name="ifAlreadyRegistered">(optional) Says how to handle existing registration with the same 
            <paramref name="serviceType"/> and <paramref name="serviceKey"/>.</param>
            <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise. 
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.Container.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if there is registered factory with the service type and key.
            To check if only default factory is registered specify <see cref="F:DryIoc.DefaultKey.Value"/> as <paramref name="serviceKey"/>.
            Otherwise, if no <paramref name="serviceKey"/> specified then True will returned for any registered factories, even keyed.
            Additionally you can specify <paramref name="condition"/> to be applied to registered factories.</summary>
            <param name="serviceType">Service type to look for.</param>
            <param name="serviceKey">Service key to look for.</param>
            <param name="factoryType">Expected registered factory type.</param>
            <param name="condition">Expected factory condition.</param>
            <returns>True if factory is registered, false if not.</returns>
        </member>
        <member name="M:DryIoc.Container.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified factory from registry. 
            Factory is removed only from registry, if there is relevant cache, it will be kept.
            Use <see cref="M:DryIoc.Container.WithoutCache"/> to remove all the cache.</summary>
            <param name="serviceType">Service type to look for.</param>
            <param name="serviceKey">Service key to look for.</param>
            <param name="factoryType">Expected factory type.</param>
            <param name="condition">Expected factory condition.</param>
        </member>
        <member name="P:DryIoc.Container.DryIoc#IScopeAccess#SingletonScope">
            <summary>Scope containing container singletons.</summary>
        </member>
        <member name="M:DryIoc.Container.DryIoc#IScopeAccess#GetCurrentNamedScope(System.Object,System.Boolean)">
            <summary>Gets current scope matching the <paramref name="name"/>. 
            If name is null then current scope is returned, or if there is no current scope then exception thrown.</summary>
            <param name="name">May be null</param> <param name="throwIfNotFound">Says to throw if no scope found.</param>
            <returns>Found scope or throws exception.</returns>
            <exception cref="T:DryIoc.ContainerException"> with code <see cref="F:DryIoc.Error.NoMatchedScopeFound"/>.</exception>
        </member>
        <member name="M:DryIoc.Container.DryIoc#IScopeAccess#GetOrCreateResolutionScope(DryIoc.IScope@,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param> 
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.Container.GetOrNewResolutionScope(DryIoc.IScope,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param> 
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.Container.DryIoc#IScopeAccess#GetMatchingResolutionScope(DryIoc.IScope,System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>If both <paramref name="assignableFromServiceType"/> and <paramref name="serviceKey"/> are null, 
            then returns input <paramref name="scope"/>.
            Otherwise searches scope hierarchy to find first scope with: Type assignable <paramref name="assignableFromServiceType"/> and 
            Key equal to <paramref name="serviceKey"/>.</summary>
            <param name="scope">Scope to start matching with Type and Key specified.</param>
            <param name="assignableFromServiceType">Type to match.</param> <param name="serviceKey">Key to match.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <param name="throwIfNotFound">Says to throw if no scope found.</param>
            <returns>Matching scope or throws <see cref="T:DryIoc.ContainerException"/>.</returns>
        </member>
        <member name="P:DryIoc.Container.Rules">
            <summary>The rules object defines policies per container for registration and resolution.</summary>
        </member>
        <member name="P:DryIoc.Container.IsDisposed">
            <summary>Indicates that container is disposed.</summary>
        </member>
        <member name="P:DryIoc.Container.DryIoc#IContainer#EmptyRequest">
            <summary>Empty request bound to container. All other requests are created by pushing to empty request.</summary>
        </member>
        <member name="P:DryIoc.Container.DryIoc#IContainer#ContainerWeakRef">
            <summary>Self weak reference, with readable message when container is GCed/Disposed.</summary>
        </member>
        <member name="M:DryIoc.Container.InjectPropertiesAndFields(System.Object,DryIoc.PropertiesAndFieldsSelector)">
            <summary>For given instance resolves and sets properties and fields.</summary>
            <param name="instance">Service instance with properties to resolve and initialize.</param>
            <param name="propertiesAndFields">(optional) Function to select properties and fields, overrides all other rules if specified.
            If not specified then method will use container <see cref="P:DryIoc.Rules.PropertiesAndFields"/>, 
            or if not specified method fallbacks to <see cref="F:DryIoc.PropertiesAndFields.Auto"/>.</param>
            <returns>Instance with assigned properties and fields.</returns>
            <remarks>Different Rules could be combined together using <see cref="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/> method.</remarks>        
        </member>
        <member name="M:DryIoc.Container.CacheFactoryExpression(System.Int32,System.Linq.Expressions.Expression)">
            <summary>Adds factory expression to cache identified by factory ID (<see cref="P:DryIoc.Factory.FactoryID"/>).</summary>
            <param name="factoryID">Key in cache.</param>
            <param name="factoryExpression">Value to cache.</param>
        </member>
        <member name="M:DryIoc.Container.GetCachedFactoryExpressionOrDefault(System.Int32)">
            <summary>Searches and returns cached factory expression, or null if not found.</summary>
            <param name="factoryID">Factory ID to lookup by.</param> <returns>Found expression or null.</returns>
        </member>
        <member name="P:DryIoc.Container.ResolutionStateCache">
            <summary>State item objects which may include: singleton instances for fast access, reuses, reuse wrappers, factory delegates, etc.</summary>
        </member>
        <member name="M:DryIoc.Container.GetOrAddStateItem(System.Object)">
            <summary>Adds item if it is not already added to singleton state, returns added or existing item index.</summary>
            <param name="item">Item to find in existing items with <see cref="M:System.Object.Equals(System.Object,System.Object)"/> or add if not found.</param>
            <returns>Index of found or added item.</returns>
        </member>
        <member name="M:DryIoc.Container.GetOrAddStateItemExpression(System.Object,System.Type,System.Boolean)">
            <summary>If possible wraps added item in <see cref="T:System.Linq.Expressions.ConstantExpression"/> (possible for primitive type, Type, strings), 
            otherwise invokes <see cref="M:DryIoc.Container.GetOrAddStateItem(System.Object)"/> and wraps access to added item (by returned index) into expression: <c>state => state.Get(index)</c>.</summary>
            <param name="item">Item to wrap or to add.</param> <param name="itemType">(optional) Specific type of item, otherwise item <see cref="M:System.Object.GetType"/>.</param>
            <param name="throwIfStateRequired">(optional) Enable filtering of stateful items.</param>
            <returns>Returns constant or state access expression for added items.</returns>
        </member>
        <member name="T:DryIoc.ContainerTools">
            <summary>Convenient methods that require container.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.InjectPropertiesAndFields``1(DryIoc.IContainer,``0,DryIoc.PropertiesAndFieldsSelector)">
            <summary>For given instance resolves and sets properties and fields.
            It respects <see cref="P:DryIoc.Rules.PropertiesAndFields"/> rules set per container, 
            or if rules are not set it uses <see cref="F:DryIoc.PropertiesAndFields.Auto"/>, 
            or you can specify your own rules with <paramref name="propertiesAndFields"/> parameter.</summary>
            <typeparam name="TService">Input and returned instance type.</typeparam>Service (wrapped)
            <param name="container">Usually a container instance, cause <see cref="T:DryIoc.Container"/> implements <see cref="T:DryIoc.IResolver"/></param>
            <param name="instance">Service instance with properties to resolve and initialize.</param>
            <param name="propertiesAndFields">(optional) Function to select properties and fields, overrides all other rules if specified.</param>
            <returns>Input instance with resolved dependencies, to enable fluent method composition.</returns>
            <remarks>Different Rules could be combined together using <see cref="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/> method.</remarks>        
        </member>
        <member name="M:DryIoc.ContainerTools.New(DryIoc.IContainer,System.Type,DryIoc.Made)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="concreteType">Type to instantiate. Wrappers (Func, Lazy, etc.) is also supported.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <typeparam name="T">Type to instantiate.</typeparam>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made.TypedMade{``0})">
            <summary>Creates service given strongly-typed creation expression. 
            Can be used to invoke arbitrary method returning some value with injecting its parameters from container.</summary>
            <typeparam name="T">Method or constructor result type.</typeparam> 
            <param name="container">Container to use for injecting dependencies.</param>
            <param name="made">Creation expression.</param>
            <returns>Created result.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterMapping(DryIoc.IContainer,System.Type,System.Type,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type. 
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param> <param name="serviceType">New service type.</param>
            <param name="registeredServiceType">Existing registered service type.</param>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <remarks>Does nothing if registration is already exists.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterMapping``2(DryIoc.IContainer,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type. 
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param>
            <typeparam name="TService">New service type.</typeparam>
            <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <remarks>Does nothing if registration is already exists.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Adds rule to register unknown service when it is resolved.</summary>
            <param name="container">Container to add rule to.</param>
            <param name="implTypes">Provider of implementation types.</param>
            <param name="changeDefaultReuse">(optional) Delegate to change auto-detected (Singleton or Current) scope reuse to another reuse.</param>
            <param name="condition">(optional) condition.</param>
            <returns>Container with new rule.</returns>
            <remarks>Types provider will be asked on each rule evaluation.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Adds rule to register unknown service when it is resolved.</summary>
            <param name="container">Container to add rule to.</param>
            <param name="implTypeAssemblies">Provides assembly with implementation types.</param>
            <param name="changeDefaultReuse">(optional) Delegate to change auto-detected (Singleton or Current) scope reuse to another reuse.</param>
            <param name="condition">(optional) condition.</param>
            <returns>Container with new rule.</returns>
            <remarks>Implementation types will be requested from assemblies only once, in this method call.</remarks>
        </member>
        <member name="F:DryIoc.ContainerTools.SetupAsResolutionRoots">
            <summary>Pre-defined what-registrations predicate for <seealso cref="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Collections.Generic.KeyValuePair{DryIoc.ServiceRegistrationInfo,System.Linq.Expressions.Expression{DryIoc.FactoryDelegate}}[]@,System.Collections.Generic.KeyValuePair{DryIoc.RequestInfo,System.Linq.Expressions.Expression}[]@,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Collections.Generic.KeyValuePair{DryIoc.ServiceRegistrationInfo,System.Linq.Expressions.Expression{DryIoc.FactoryDelegate}}[]@,System.Collections.Generic.KeyValuePair{DryIoc.RequestInfo,System.Linq.Expressions.Expression}[]@,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Generates all resolution root and calls expressions.</summary>
            <param name="container">For container</param>
            <param name="resolutions">Result resolution factory expressions. They could be compiled and used for actual service resolution.</param>
            <param name="resolutionCallDependencies">Resolution call dependencies (implemented via Resolve call): e.g. dependencies wrapped in Lazy{T}.</param>
            <param name="whatRegistrations">(optional) Allow to filter what registration to resolve. By default applies to all registrations.
            You may use <see cref="F:DryIoc.ContainerTools.SetupAsResolutionRoots"/> to generate only for registrations with <see cref="P:DryIoc.Setup.AsResolutionRoot"/>.</param>
            <returns>Errors happened when resolving corresponding registrations.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.VerifyResolutions(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>May be used to find potential problems in service registration setup.
            Methods tries to get expressions for Roots/All registrations, collects happened exceptions, and
            returns them to user. Does not create any actual service objects.</summary>
            <param name="container">for container</param>
            <param name="whatRegistrations">(optional) Allow to filter what registration to resolve. By default applies to all registrations.</param>
            <returns>Exceptions happened for corresponding registrations.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.IsSupportedInjectedCustomValueType(System.Type)">
            <summary>Checks if custom value of the <paramref name="customValueType"/> is supported by DryIoc injection mechanism.</summary>
            <param name="customValueType">Type to check</param> <returns>True if supported, false otherwise.c</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.RequestInfoToExpression(DryIoc.IContainer,DryIoc.RequestInfo)">
            <summary>Represents construction of whole request info stack as expression.</summary>
            <param name="container">Required to access container facilities for expression conversion.</param>
            <param name="request">Request info to convert to expression.</param>
            <returns>Returns result expression.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.GetCurrentScope(DryIoc.IContainer,System.Object,System.Boolean)">
            <summary>Returns the current scope, or null if not opened and <paramref name="throwIfNotFound"/> is not set.</summary>
            <param name="container">Container with scope to check.</param>
            <param name="name">(optional) Name of scpoe to search in current scope or its parents.</param>
            <param name="throwIfNotFound">(optional) Dictates to throw exception if scope if not found.</param>
            <returns>Scope if found, or null otherwise (if <paramref name="throwIfNotFound"/> is not set).</returns>
        </member>
        <member name="T:DryIoc.ReuseToExpressionConverter">
            <summary>Converter of given reuse to its code representation as expression tree.</summary>
        </member>
        <member name="M:DryIoc.ReuseToExpressionConverter.ToExpression(DryIoc.IReuse,DryIoc.IContainer)">
            <summary>Converts given reuse to its code representation in expression tree.</summary>
            <param name="reuse">Reuse to convert</param> <param name="container"></param>
        </member>
        <member name="T:DryIoc.IConvertibleToExpression">
            <summary>Interface used to convert reuse instance to expression.</summary>
        </member>
        <member name="M:DryIoc.IConvertibleToExpression.Convert">
            <summary>Returns expression representation.</summary> <returns>subj.</returns>
        </member>
        <member name="T:DryIoc.DefaultKey">
            <summary>Used to represent multiple default service keys. 
            Exposes <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/> to determine order of service added.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.Value">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.RegistrationOrder">
            <summary>Allows to determine service registration order.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Of(System.Int32)">
            <summary>Create new default key with specified registration order.</summary>
            <param name="registrationOrder"></param> <returns>New default key.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.Next">
            <summary>Returns next default key with increased <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/>.</summary>
            <returns>New key.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.Equals(System.Object)">
            <summary>Compares keys based on registration order.</summary>
            <param name="key">Key to compare with.</param>
            <returns>True if keys have the same order.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.GetHashCode">
            <summary>Returns registration order as hash.</summary> <returns>Hash code.</returns>
        </member>
        <member name="M:DryIoc.DefaultKey.ToString">
            <summary>Prints registration order to string.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.IResolverContext">
            <summary>Returns reference to actual resolver implementation. 
            Minimizes dependency to Factory Delegate on container.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Resolver">
            <summary>Provides access to resolver implementation.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Scopes">
            <summary>Scopes access.</summary>
        </member>
        <member name="T:DryIoc.ContainerWeakRef">
            <summary>Guards access to <see cref="P:DryIoc.ContainerWeakRef.Container"/> WeakReference target with more DryIoc specific exceptions.</summary>
        </member>
        <member name="P:DryIoc.ContainerWeakRef.Resolver">
            <summary>Provides access to resolver implementation.</summary>
        </member>
        <member name="P:DryIoc.ContainerWeakRef.Scopes">
            <summary>Scope access.</summary>
        </member>
        <member name="P:DryIoc.ContainerWeakRef.Container">
            <summary>Container access.</summary>
        </member>
        <member name="M:DryIoc.ContainerWeakRef.GetTarget">
            <summary>Returns target container when it is not null and not disposed. Otherwise throws exception.</summary>
            <returns>Target container.</returns>
        </member>
        <member name="M:DryIoc.ContainerWeakRef.#ctor(DryIoc.IContainer)">
            <summary>Creates weak reference wrapper over passed container object.</summary> <param name="container">Object to wrap.</param>
        </member>
        <member name="T:DryIoc.FactoryDelegate">
            <summary>The delegate type which is actually used to create service instance by container.
            Delegate instance required to be static with all information supplied by <paramref name="state"/> and <paramref name="scope"/>
            parameters. The requirement is due to enable compilation to DynamicMethod in DynamicAssembly, and also to simplify
            state management and minimizes memory leaks.</summary>
            <param name="state">All the state items available in resolution root.</param>
            <param name="r">Provides access to <see cref="T:DryIoc.IResolver"/> implementation to enable nested/dynamic resolve inside:
            registered delegate factory, <see cref="T:System.Lazy`1"/>, and <see cref="T:DryIoc.LazyEnumerable`1"/>.</param>
            <param name="scope">Resolution root scope: initially passed value will be null, but then the actual will be created on demand.</param>
            <returns>Created service object.</returns>
        </member>
        <member name="T:DryIoc.FactoryCompiler">
            <summary>Handles default conversation of expression into <see cref="T:DryIoc.FactoryDelegate"/>.</summary>
        </member>
        <member name="M:DryIoc.FactoryCompiler.WrapInFactoryExpression(System.Linq.Expressions.Expression)">
            <summary>Wraps service creation expression (body) into <see cref="T:DryIoc.FactoryDelegate"/> and returns result lambda expression.</summary>
            <param name="expression">Service expression (body) to wrap.</param> <returns>Created lambda expression.</returns>
        </member>
        <member name="M:DryIoc.FactoryCompiler.CompileToDelegate(System.Linq.Expressions.Expression,DryIoc.IContainer)">
            <summary>First wraps the input service creation expression into lambda expression and
            then compiles lambda expression to actual <see cref="T:DryIoc.FactoryDelegate"/> used for service resolution.
            By default it is using Expression.Compile but if corresponding rule specified (available on .Net 4.0 and higher),
            it will compile to DymanicMethod/Assembly.</summary>
            <param name="expression">Service expression (body) to wrap.</param>
            <param name="container">To access container state that may be required for compilation.</param>
            <returns>Compiled factory delegate to use for service resolution.</returns>
        </member>
        <member name="T:DryIoc.WrappersSupport">
            <summary>Adds to Container support for:
            <list type="bullet">
            <item>Open-generic services</item>
            <item>Service generics wrappers and arrays using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> extension point.
            Supported wrappers include: Func of <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, Lazy, Many, IEnumerable, arrays, Meta, KeyValuePair, DebugExpression.
            All wrapper factories are added into collection <see cref="F:DryIoc.WrappersSupport.Wrappers"/> and searched by <see cref="M:DryIoc.WrappersSupport.ResolveWrapperOrGetDefault(DryIoc.Request)"/>
            unregistered resolution rule.</item>
            </list></summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.FuncTypes">
            <summary>Supported Func types up to 4 input parameters.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.ArrayInterfaces">
            <summary>Supported open-generic collection types.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsSupportedCollectionType(System.Type)">
            <summary>Checks if passed type represents supported collection types.</summary>
            <param name="type">Type to examine.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsFunc(System.Type)">
            <summary>Returns true if type is supported <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, and false otherwise.</summary>
            <param name="type">Type to check.</param><returns>True for func type, false otherwise.</returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsFuncWithArgs(System.Type)">
            <summary>Returns true if type is func with 1 or more input arguments.</summary>
            <param name="type">Type to check.</param><returns>True for func type, false otherwise.</returns>
        </member>
        <member name="F:DryIoc.WrappersSupport.Wrappers">
            <summary>Registered wrappers by their concrete or generic definition service type.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.ResolveWrapperOrGetDefault(DryIoc.Request)">
            <summary>Returns wrapper factory. For open-generic wrapper - generated closed factory first.</summary>
            <param name="request">Wrapper request.</param>
            <returns>Found wrapper factory or default null otherwise.</returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetMetaExpressionOrDefault(DryIoc.Request)">
            <remarks>If service key is not specified in request then method will search for all
            registered factories with the same metadata type ignoring keys.</remarks>
        </member>
        <member name="T:DryIoc.Rules">
            <summary> Defines resolution/registration rules associated with Container instance. They may be different for different containers.</summary>
        </member>
        <member name="F:DryIoc.Rules.Default">
            <summary>No rules as staring point.</summary>
        </member>
        <member name="F:DryIoc.Rules.LevelToSplitObjectGraphIntoResolveCalls">
            <summary>Dependency nesting level where to split object graph into separate Resolve call 
            to optimize performance of large object graph.</summary>
            <remarks>At the moment the value is predefined. Not sure if it should be user-defined.</remarks>
        </member>
        <member name="P:DryIoc.Rules.FactoryMethod">
            <summary>Shorthand to <see cref="P:DryIoc.Made.FactoryMethod"/></summary>
        </member>
        <member name="P:DryIoc.Rules.Parameters">
            <summary>Shorthand to <see cref="P:DryIoc.Made.Parameters"/></summary>
        </member>
        <member name="P:DryIoc.Rules.PropertiesAndFields">
            <summary>Shorthand to <see cref="P:DryIoc.Made.PropertiesAndFields"/></summary>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Returns new instance of the rules with specified <see cref="T:DryIoc.Made"/>.</summary>
            <returns>New rules with specified <see cref="T:DryIoc.Made"/>.</returns>
        </member>
        <member name="T:DryIoc.Rules.FactorySelectorRule">
            <summary>Defines single factory selector delegate.</summary>
            <param name="request">Provides service request leading to factory selection.</param>
            <param name="factories">Registered factories with corresponding key to select from.</param>
            <returns>Single selected factory, or null if unable to select.</returns>
        </member>
        <member name="P:DryIoc.Rules.FactorySelector">
            <summary>Rules to select single matched factory default and keyed registered factory/factories. 
            Selectors applied in specified array order, until first returns not null <see cref="T:DryIoc.Factory"/>.
            Default behavior is throw on multiple registered default factories, cause it is not obvious what to use.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFactorySelector(DryIoc.Rules.FactorySelectorRule)">
            <summary>Sets <see cref="P:DryIoc.Rules.FactorySelector"/></summary> 
            <param name="rule">Selectors to set, could be null to use default approach.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.SelectLastRegisteredFactory">
            <summary>Select last registered factory from multiple default.</summary>
            <returns>Factory selection rule.</returns>
        </member>
        <member name="M:DryIoc.Rules.SelectKeyedOverDefaultFactory(System.Object)">
            <summary>Prefer specified service key (if found) over default key.
            Help to override default registrations in Open Scope scenarios: I may register service with key and resolve it as default in current scope.</summary>
            <param name="serviceKey">Service key to look for instead default.</param>
            <returns>Found factory or null.</returns>
        </member>
        <member name="T:DryIoc.Rules.UnknownServiceResolver">
            <summary>Defines delegate to return factory for request not resolved by registered factories or prior rules.
            Applied in specified array order until return not null <see cref="T:DryIoc.Factory"/>.</summary> 
            <param name="request">Request to return factory for</param> <returns>Factory to resolve request, or null if unable to resolve.</returns>
        </member>
        <member name="P:DryIoc.Rules.UnknownServiceResolvers">
            <summary>Gets rules for resolving not-registered services. Null by default.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceResolvers(DryIoc.Rules.UnknownServiceResolver[])">
            <summary>Appends resolver to current unknown service resolvers.</summary>
            <param name="rules">Rules to append.</param> <returns>New Rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutUnknownServiceResolver(DryIoc.Rules.UnknownServiceResolver)">
            <summary>Removes specified resolver from unknown service resolvers, and returns new Rules.
            If no resolver was found then <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> will stay the same instance, 
            so it could be check for remove success or fail.</summary>
            <param name="rule">Rule tor remove.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.AutoResolveConcreteTypeRule(System.Func{DryIoc.Request,System.Boolean})">
            <summary>Rule to automatically resolves non-registered service type which is: nor interface, nor abstract.
            For constructor selection we are using <see cref="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments"/>.
            The resolution creates transient services.</summary>
            <param name="condition">(optional) Selects resolution path to apply the rule.</param>
            <returns>New rule.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithAutoConcreteTypeResolution(System.Func{DryIoc.Request,System.Boolean})">
            <summary>Automatically resolves non-registered service type which is: nor interface, nor abstract.
            For constructor selection we are using <see cref="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments"/>.
            The resolution creates transient services.</summary>
            <param name="condition">(optional) Selects resolution path to apply the rule.</param>
            <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.AutoRegisterUnknownServiceRule(System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Fallback rule to automatically register requested service with Reuse based on resolution source.</summary>
            <param name="implTypes">Assemblies to look for implementation types.</param>
            <param name="changeDefaultReuse">(optional) Delegate to change auto-detected (Singleton or Current) scope reuse to another reuse.</param>
            <param name="condition">(optional) Selects when to apply the rule.</param>
            <returns>New rule.</returns>
        </member>
        <member name="P:DryIoc.Rules.FallbackContainers">
            <summary>List of containers to fallback resolution to.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFallbackContainer(DryIoc.IContainer)">
            <summary>Appends WeakReference to new fallback container to the end of the list.</summary>
            <param name="container">To append.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithoutFallbackContainer(DryIoc.IContainer)">
            <summary>Removes WeakReference to fallback container from the list.</summary>
            <param name="container">To remove.</param> <returns>New rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.DefaultReuseInsteadOfTransient">
            <summary><see cref="M:DryIoc.Rules.WithDefaultReuseInsteadOfTransient(DryIoc.IReuse)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultReuseInsteadOfTransient(DryIoc.IReuse)">
            <summary>Sets different default reuse per container rules. Default is Transient.</summary>
            <param name="defaultReuseInsteadOfTransient">Reuse value.</param> 
            <returns>New rules with new reuse.</returns>
        </member>
        <member name="T:DryIoc.Rules.ItemToExpressionConverterRule">
            <summary>Given item object and its type should return item "pure" expression presentation, 
            without side-effects or external dependencies. 
            e.g. for string "blah" <code lang="cs"><![CDATA[]]>Expression.Constant("blah", typeof(string))</code>.
            If unable to convert should return null.</summary>
            <param name="item">Item object. Item is not null.</param> 
            <param name="itemType">Item type. Item type is not null.</param>
            <returns>Expression or null.</returns>
        </member>
        <member name="P:DryIoc.Rules.ItemToExpressionConverter">
            <summary><see cref="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)">
            <summary>Specifies custom rule to convert non-primitive items to their expression representation.
            That may be required because DryIoc by default does not support non-primitive service keys and registration metadata.
            To enable non-primitive values support DryIoc need a way to recreate them as expression tree.</summary>
            <returns>New rules</returns>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfDependencyHasShorterReuseLifespan">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan">
            <summary>Turns off throwing exception when dependency has shorter reuse lifespan than its parent or ancestor.</summary>
            <returns>New rules with new setting value.</returns>
        </member>
        <member name="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient">
            <summary>Turns Off the rule <see cref="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient"/>.
            Allows to register disposable transient but it is up to you to handle their disposal.
            You can use <see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/> to actually track disposable transient in
            container, so that disposal will be handled by container.</summary>
            <returns>New rules with setting turned off.</returns>
        </member>
        <member name="P:DryIoc.Rules.TrackingDisposableTransients">
            <summary><see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithTrackingDisposableTransients">
            <summary>Turns tracking of disposable transients in dependency parent scope, or in current scope if service
            is resolved directly. 
            
            If no open scope at the moment then resolved transient won't be tracked and it is up to you
            to dispose it! That's is similar situation to creating service by new - you have full control.
            
            If dependency wrapped in Func somewhere in parent chain then it also won't be tracked, because
            Func supposedly means multiple object creation and for container it is not clear what to do, so container
            delegates that to user. Func here is the similar to Owned relationship type in Autofac library.
            </summary>
            <remarks>Turning this setting On automatically turns off <see cref="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient"/>.</remarks>
            <returns>New rules with setting turned On.</returns>
        </member>
        <member name="P:DryIoc.Rules.EagerCachingSingletonForFasterAccess">
            <summary><see cref="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess">
            <summary>Turns off optimization: creating singletons during resolution of object graph.</summary>
            <returns>New rules with singleton optimization turned off.</returns>
        </member>
        <member name="P:DryIoc.Rules.DependencyResolutionCallExpressions">
            <summary><see cref="M:DryIoc.Rules.WithDependencyResolutionCallExpressions"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDependencyResolutionCallExpressions">
            <summary>Specifies to generate ResolutionCall dependency creation expression
            and put it into collection.</summary>
            <returns>New rules with resolution call expressions to be populated.</returns>
        </member>
        <member name="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope">
            <summary><see cref="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutImplicitCheckForReuseMatchingScope">
            <summary>Removes implicit Factory <see cref="P:DryIoc.Setup.Condition"/> for non-transient service.
            The Condition filters out factory without matching scope.</summary>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="P:DryIoc.Rules.ResolveIEnumerableAsLazyEnumerable">
            <summary><see cref="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable">
            <summary>Specifies to resolve IEnumerable as LazyEnumerable.</summary>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="P:DryIoc.Rules.VariantGenericTypesInResolvedCollection">
            <summary><see cref="M:DryIoc.Rules.WithoutVariantGenericTypesInResolvedCollection"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutVariantGenericTypesInResolvedCollection">
            <summary>Flag instructs to include covariant compatible types in resolved collection.</summary>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="P:DryIoc.Rules.DefaultIfAlreadyRegistered">
            <summary><seew cref="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)">
            <summary>Specifies default setting for container. By default is <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/>.
            Example of use: specify Keep as a container default, then set AppendNonKeyed for explicit collection registrations.</summary>
            <param name="rule">New setting.</param> <returns>New rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.ImplicitOpenedRootScope">
            <summary><see cref="M:DryIoc.Rules.WithImplicitRootOpenScope"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithImplicitRootOpenScope">
            <summary>Specifies to open scope as soon as container is created (the same as for Singleton scope).
            That way you don't need to call <see cref="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/>. 
            Implicitly opened scope will be disposed together with Singletons when container is disposed.</summary> 
            <remarks>The setting is only valid for container without ambient scope context.</remarks>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfRuntimeStateRequired">
            <summary><see cref="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired">
            <summary>Specifies to throw an exception in attempt to resolve service which require runtime state for resolution.
            Runtime state may be introduced by RegisterDelegate, RegisterInstance, or registering with non-primitive service key, or metadata.</summary>
            <returns>Returns new rules with flag set.</returns>
        </member>
        <member name="T:DryIoc.FactoryMethod">
            <summary>Wraps constructor or factory method optionally with factory instance to create service.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorOrMethodOrMember">
            <summary>Constructor or method to use for service creation.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.FactoryServiceInfo">
            <summary>Identifies factory service if factory method is instance member.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo)">
            <summary>Wraps method and factory instance.</summary>
            <param name="ctorOrMethodOrMember">Constructor, static or instance method, property or field.</param>
            <param name="factoryInfo">Factory info to resolve in case of instance <paramref name="ctorOrMethodOrMember"/>.</param>
            <returns>New factory method wrapper.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.ToString">
            <summary>Pretty prints wrapped method.</summary> <returns>Printed string.</returns>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments">
            <summary>Searches for constructor with all resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving as service and as Func of TArgs... returning TService.</summary>
        </member>
        <member name="T:DryIoc.Made">
            <summary>Rules how to: <list type="bullet">
            <item>Select constructor for creating service with <see cref="P:DryIoc.Made.FactoryMethod"/>.</item>
            <item>Specify how to resolve constructor parameters with <see cref="P:DryIoc.Made.Parameters"/>.</item>
            <item>Specify what properties/fields to resolve and how with <see cref="P:DryIoc.Made.PropertiesAndFields"/>.</item>
            </list></summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethod">
            <summary>Returns delegate to select constructor based on provided request.</summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethodKnownResultType">
            <summary>Return type of strongly-typed factory method expression.</summary>
        </member>
        <member name="P:DryIoc.Made.HasCustomDependencyValue">
            <summary>True is made has properties or parameters with custom value.
            That's mean the whole made become context based which affects caching</summary>
        </member>
        <member name="P:DryIoc.Made.Parameters">
            <summary>Specifies how constructor parameters should be resolved: 
            parameter service key and type, throw or return default value if parameter is unresolved.</summary>
        </member>
        <member name="P:DryIoc.Made.PropertiesAndFields">
            <summary>Specifies what <see cref="T:DryIoc.ServiceInfo"/> should be used when resolving property or field.</summary>
        </member>
        <member name="F:DryIoc.Made.Default">
            <summary>Container will use some sensible defaults for service creation.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.FactoryMethodSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethod"/> specified.</summary>
            <param name="factoryMethod">To use.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.ParameterSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.Parameters"/> specified.</summary>
            <param name="parameters">To use.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.PropertiesAndFieldsSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.PropertiesAndFields"/> specified.</summary>
            <param name="propertiesAndFields">To use.</param> <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
            <param name="factoryMethod">(optional)</param> <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New injection rules or <see cref="F:DryIoc.Made.Default"/>.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethod)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
            <param name="factoryMethod">Known factory method.</param>
            <returns>New injection rules.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo)">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethod"/> specified.</summary>
            <param name="factoryMethodOrMember">To create service.</param>
            <param name="factoryInfo">(optional) Factory info to resolve in case of instance member.</param>
            <returns>New rules.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Reflection.MemberInfo},DryIoc.ServiceInfo)">
            <summary>Creates factory specification with method or member selector based on request.</summary>
            <param name="getMethodOrMember">Method, or constructor, or member selector.</param>
            <param name="factoryInfo">(optional) Factory info to resolve in case of instance method/member.</param>
            <returns>New specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{System.Type,System.Reflection.ConstructorInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Defines how to select constructor from implementation type.</summary>
            <param name="getConstructor">Delegate taking implementation type as input and returning selected constructor info.</param>
            <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New instance of <see cref="T:DryIoc.Made"/> with <see cref="P:DryIoc.Made.FactoryMethod"/> set to specified delegate.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{DryIoc.RequestInfo,System.Object}[])">
            <summary>Defines factory method using expression of constructor call (with properties), or static method call.</summary>
            <typeparam name="TService">Type with constructor or static method.</typeparam>
            <param name="serviceReturningExpr">Expression tree with call to constructor with properties: 
            <code lang="cs"><![CDATA[() => new Car(Arg.Of<IEngine>()) { Color = Arg.Of<Color>("CarColor") }]]></code>
            or static method call <code lang="cs"><![CDATA[() => Car.Create(Arg.Of<IEngine>())]]></code></param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``2(System.Func{DryIoc.Request,DryIoc.ServiceInfo.Typed{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{DryIoc.RequestInfo,System.Object}[])">
            <summary>Defines creation info from factory method call Expression without using strings.
            You can supply any/default arguments to factory method, they won't be used, it is only to find the <see cref="T:System.Reflection.MethodInfo"/>.</summary>
            <typeparam name="TFactory">Factory type.</typeparam> <typeparam name="TService">Factory product type.</typeparam>
            <param name="getFactoryInfo">Returns or resolves factory instance.</param> 
            <param name="serviceReturningExpr">Method, property or field expression returning service.</param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="T:DryIoc.Made.TypedMade`1">
            <summary>Typed version of <see cref="T:DryIoc.Made"/> specified with statically typed expression tree.</summary>
            <typeparam name="TService">Type that expression returns.</typeparam>
        </member>
        <member name="M:DryIoc.Made.TypedMade`1.#ctor(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector,System.Boolean)">
            <summary>Creates typed version.</summary>
            <param name="factoryMethod"></param> <param name="parameters"></param> <param name="propertiesAndFields"></param>
            <param name="hasCustomValue"></param>
        </member>
        <member name="T:DryIoc.Arg">
            <summary>Class for defining parameters/properties/fields service info in <see cref="T:DryIoc.Made"/> expressions.
            Its methods are NOT actually called, they just used to reflect service info from call expression.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1">
            <summary>Specifies required service type of parameter or member. If required type is the same as parameter/member type,
            the method is just a placeholder to help detect constructor or factory method, and does not have additional meaning.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``2">
            <summary>Specifies both service and required service types.</summary>
            <typeparam name="TService">Service type.</typeparam> <typeparam name="TRequired">Required service type.</typeparam>
            <returns>Ignored default of Service type.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved)">
            <summary>Specifies both service and required service types.</summary>
            <typeparam name="TService">Service type.</typeparam> <typeparam name="TRequired">Required service type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <returns>Ignored default of Service type.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="serviceKey">Service key object.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``2(System.Object)">
            <summary>Specifies both service and required service types.</summary>
            <typeparam name="TService">Service type.</typeparam> <typeparam name="TRequired">Required service type.</typeparam>
            <param name="serviceKey">Service key object.</param>
            <returns>Ignored default of Service type.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy. Plus specifies service key.</summary>
            <typeparam name="TRequired">Required service type if different from parameter/member type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <param name="serviceKey">Service key object.</param>
            <returns>Returns some (ignored) value.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies both service and required service types.</summary>
            <typeparam name="TService">Service type.</typeparam> <typeparam name="TRequired">Required service type.</typeparam>
            <param name="ifUnresolved">Defines to throw or to return default if unresolved.</param>
            <param name="serviceKey">Service key object.</param>
            <returns>Ignored default of Service type.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
            <typeparam name="TRequired">Required service type.</typeparam>
            <param name="defaultValue">Primitive default value.</param>
            <param name="ifUnresolved">Only the <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> value is accepted.</param>
            <returns>Ignored.</returns>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
            <typeparam name="TRequired">Required service type.</typeparam>
            <param name="defaultValue">Primitive default value.</param>
            <param name="ifUnresolved">Only the <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> value is accepted.</param>
            <param name="serviceKey">Service key object.</param>
            <returns>Ignored.</returns>
        </member>
        <member name="M:DryIoc.Arg.Index``1(System.Int32)">
            <summary>Specifies argument index starting from 0 to use corresponding custom value factory, 
            similar to String.Format <c>"{0}, {1}, etc"</c>.</summary>
            <typeparam name="T">Type of dependency. Difference from actual parameter type is ignored.</typeparam>
            <param name="argIndex">Argument index starting from 0</param> <returns>Ignored.</returns>
        </member>
        <member name="F:DryIoc.Arg.ArgIndexMethodName">
            <summary>Name is close to method itself to not forget when renaming the method.</summary>
        </member>
        <member name="T:DryIoc.Registrator">
            <summary>Contains <see cref="T:DryIoc.IRegistrator"/> extension methods to simplify general use cases.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.Factory,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service of <paramref name="serviceType"/>.</summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">The service type to register</param>
            <param name="factory"><see cref="T:DryIoc.Factory"/> details object.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional Could be of any type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service <paramref name="serviceType"/> with corresponding <paramref name="implementationType"/>.</summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">The service type to register.</param>
            <param name="implementationType">Implementation type. Concrete and open-generic class are supported.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. 
                Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service of <paramref name="serviceAndMayBeImplementationType"/>. ServiceType will be the same as <paramref name="serviceAndMayBeImplementationType"/>.</summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceAndMayBeImplementationType">Implementation type. Concrete and open-generic class are supported.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service of <typeparamref name="TService"/> type implemented by <typeparamref name="TImplementation"/> type.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <typeparam name="TImplementation">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers implementation type <typeparamref name="TImplementation"/> with itself as service type.</summary>
            <typeparam name="TImplementation">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) specifies <see cref="T:DryIoc.Made"/>.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``1},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <typeparam name="TMadeResult">The type returned by Made expression.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="made">Made specified with strongly-typed service creation expression.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="made">Made specified with strongly-typed service creation expression.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) Factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="T:DryIoc.Registrator.RegisterManyAction">
            <summary>Action that could be used by User to customize register many default behavior.</summary>
            <param name="r">Registrator provided to do any arbitrary registration User wants.</param>
            <param name="serviceTypes">Valid service type that could be used with <paramref name="implType"/>.</param>
            <param name="implType">Concrete or open-generic implementation type.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Type[],System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers many service types with the same implementation.</summary>
            <param name="registrator">Registrator/Container</param>
            <param name="serviceTypes">1 or more service types.</param> 
            <param name="implementationType">Should implement service types. Will throw if not.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional) How to create implementation instance.</param>
            <param name="setup">(optional)</param> <param name="ifAlreadyRegistered">(optional) By default <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/></param>
            <param name="serviceKey">(optional)</param>
        </member>
        <member name="F:DryIoc.Registrator.ExcludedGeneralPurposeServiceTypes">
            <summary>List of types excluded by default from RegisterMany convention.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns only those types that could be used as service types of <paramref name="type"/>. It means that
            for open-generic <paramref name="type"/> its service type should supply all type arguments
            Used by RegisterMany method.</summary>
            <param name="type">Source type: may be concrete, abstract or generic definition.</param> 
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <returns>Array of types or empty.</returns>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},DryIoc.Registrator.RegisterManyAction,System.Boolean)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypes">Implementation type provider.</param>
            <param name="action">(optional) User specified registration action: 
            may be used to filter registrations or specify non-default registration options, e.g. Reuse or ServiceKey, etc.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypes">Implementation type provider.</param>
            <param name="reuse">(optional) Reuse to apply to all service registrations.</param>
            <param name="made">(optional) Allow to select constructor/method to create service, specify how to inject its parameters and properties/fields.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with existing service registrations.</param>
            <param name="serviceTypeCondition">(optional) Condition to select only specific service type to register.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
            <typeparam name="TImplementation">The type to get service types from.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="made">(optional) Allow to select constructor/method to create service, specify how to inject its parameters and properties/fields.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceTypeCondition">(optional) Condition to select only specific service type to register.</param>        
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
            <typeparam name="TMadeResult">The type returned by Made factory expression.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="made">Made specified with strongly-typed factory expression.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceTypeCondition">(optional) Condition to select only specific service type to register.</param>        
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},DryIoc.Registrator.RegisterManyAction,System.Boolean)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypeAssemblies">Assemblies with implementation/service types to register.</param>
            <param name="action">(optional) User specified registration action: 
            may be used to filter registrations or specify non-default registration options, e.g. Reuse or ServiceKey, etc.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Boolean},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Boolean,System.Object)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
            <param name="registrator">Registrator/Container to register with.</param>
            <param name="implTypeAssemblies">Assemblies with implementation/service types to register.</param>
            <param name="serviceTypeCondition">Condition to select only specific service type to register.</param>
            <param name="reuse">(optional) Reuse to apply to all service registrations.</param>
            <param name="made">(optional) Allow to select constructor/method to create service, specify how to inject its parameters and properties/fields.</param>
            <param name="setup">(optional) Factory setup, by default is <see cref="F:DryIoc.Setup.Default"/>, check <see cref="T:DryIoc.Setup"/> class for available setups.</param>
            <param name="ifAlreadyRegistered">(optional) Policy to deal with existing service registrations.</param>
            <param name="nonPublicServiceTypes">(optional) Include non public service types.</param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolver,``0},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers a factory delegate for creating an instance of <typeparamref name="TService"/>.
            Delegate can use <see cref="T:DryIoc.IResolver"/> parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="factoryDelegate">The delegate used to create a instance of <typeparamref name="TService"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <remarks>The method should be used as the last resort only! Though powerful it is easy to get memory leaks
            (due variables captured in delegate closure) and impossible to use in generation scenarios.
            Consider using FactoryMethod instead: 
            <code lang="cs"><![CDATA[container.Register<ICar>(with: Method.Of(() => new Car(Arg.Of<IEngine>())))]]></code>.</remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Func{DryIoc.IResolver,System.Object},DryIoc.IReuse,DryIoc.Setup,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Registers a factory delegate for creating an instance of <paramref name="serviceType"/>.
            Delegate can use <see cref="T:DryIoc.IResolver"/> parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <param name="registrator">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">Service type to register.</param>
            <param name="factoryDelegate">The delegate used to create a instance of <paramref name="serviceType"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="setup">(optional) factory setup, by default is (<see cref="F:DryIoc.Setup.Default"/>)</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegateDecorator``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolver,System.Func{``0,``0}},System.Func{DryIoc.RequestInfo,System.Boolean})">
            <summary>Registers decorator function that gets decorated value as input and returns decorator.
            Note: Delegate decorator will use <see cref="T:DryIoc.Reuse"/> of decoratee service.</summary>
            <typeparam name="TService">Registered service type to decorate.</typeparam>
            <param name="registrator">Registrator/Container.</param>
            <param name="getDecorator">Delegate returning decorating function.</param>
            <param name="condition">(optional) Condition for decorator application.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance(DryIoc.IContainer,System.Type,System.Object,DryIoc.IReuse,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>Registers an externally created object of<paramref name= "serviceType" />.
            If no reuse specified instance will be stored in Singleton Scope, and disposed when container is disposed.</summary>
            <param name="container">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceType">Service type to register.</param>
            <param name="instance">The pre-created instance of <paramref name="serviceType"/>.</param>
            <param name="reuse">(optional) By default means <see cref="F:DryIoc.Reuse.Singleton"/> as the longest available.</param>
            <param name="ifAlreadyRegistered">(optional) If Replace specified then existing instance may be replaced in scope without introducing new factory.</param>
            <param name="preventDisposal">(optional) Prevents disposal of reused instance.</param>
            <param name="weaklyReferenced">(optional) Store as WeakReference. </param>
            <param name="serviceKey">(optional) service key (name). Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance``1(DryIoc.IContainer,``0,DryIoc.IReuse,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>Registers an externally created object of <typeparamref name="TService"/>. 
            If no reuse specified instance will be stored in Singleton Scope, and disposed when container is disposed.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="container">Any <see cref="T:DryIoc.IRegistrator"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="instance">The pre-created instance of <typeparamref name="TService"/>.</param>
            <param name="reuse">(optional) <see cref="T:DryIoc.IReuse"/> implementation, e.g. <see cref="F:DryIoc.Reuse.Singleton"/>. Default value means no reuse, aka Transient.</param>
            <param name="ifAlreadyRegistered">(optional) policy to deal with case when service with such type and name is already registered.</param>
            <param name="preventDisposal">(optional) Prevents disposal of reused instance.</param>
            <param name="weaklyReferenced">(optional) Store as WeakReference. </param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInitializer``1(DryIoc.IRegistrator,System.Action{``0,DryIoc.IResolver},System.Func{DryIoc.RequestInfo,System.Boolean})">
            <summary>Registers initializing action that will be called after service is resolved just before returning it to caller.
            Check example below for using initializer to automatically subscribe to singleton event aggregator.
            You can register multiple initializers for single service. 
            Or you can register initializer for <see cref="T:System.Object"/> type to be applied for all services and use <paramref name="condition"/> 
            to filter target services. </summary>
            <typeparam name="TTarget">Any type implemented by requested service type including service type itself and object type.</typeparam>
            <param name="registrator">Usually is <see cref="T:DryIoc.Container"/> object.</param>
            <param name="initialize">Delegate with <typeparamref name="TTarget"/> object and 
            <see cref="T:DryIoc.IResolver"/> to resolve additional services required by initializer.</param>
            <param name="condition">(optional) Additional condition to select required target.</param>
            <example><code lang="cs"><![CDATA[
                container.Register<EventAggregator>(Reuse.Singleton);
                container.Register<ISubscriber, SomeSubscriber>();
            
                // Registers initializer for all subscribers implementing ISubscriber.
                container.RegisterInitiliazer<ISubscriber>((s, r) => r.Resolve<EventAggregator>().Subscribe(s));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDisposer``1(DryIoc.IRegistrator,System.Action{``0},System.Func{DryIoc.RequestInfo,System.Boolean})">
            <summary>Registers dispose action for reused target service.</summary>
            <typeparam name="TService">Target service type.</typeparam>
            <param name="registrator">Registrator to use.</param> 
            <param name="dispose">Actual dispose action to be invoke when scope is disposed.</param>
            <param name="condition">(optional) Additional way to identify the service.</param>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <paramref name="serviceType"/> is registered in container or its open generic definition is registered in container.</summary>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> to explore or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceType">The type of the registered service.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) condition to specify what registered factory do you expect.</param>
            <returns>True if <paramref name="serviceType"/> is registered, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <typeparamref name="TService"/> type is registered in container or its open generic definition is registered in container.</summary>
            <typeparam name="TService">The type of service.</typeparam>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> to explore or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) condition to specify what registered factory do you expect.</param>
            <returns>True if <typeparamref name="TService"/> name="serviceType"/> is registered, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.Registrator.Unregister(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.</summary>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> to explore or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceType">Type of service to remove.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) Factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) Condition for Factory to be removed.</param>
        </member>
        <member name="M:DryIoc.Registrator.Unregister``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.</summary>
            <typeparam name="TService">The type of service to remove.</typeparam>
            <param name="registrator">Usually <see cref="T:DryIoc.Container"/> or any other <see cref="T:DryIoc.IRegistrator"/> implementation.</param>
            <param name="serviceKey">(optional) Could be of any of type with overridden <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>.</param>
            <param name="factoryType">(optional) Factory type to lookup, <see cref="F:DryIoc.FactoryType.Service"/> by default.</param>
            <param name="condition">(optional) Condition for Factory to be removed.</param>
        </member>
        <member name="T:DryIoc.MethodImplHints">
            <summary>Portable aggressive in-lining option for MethodImpl.</summary>
        </member>
        <member name="F:DryIoc.MethodImplHints.AggressingInlining">
            <summary>Value of MethodImplOptions.AggressingInlining</summary>
        </member>
        <member name="T:DryIoc.Resolver">
            <summary>Defines convenient extension methods for <see cref="T:DryIoc.IResolver"/>.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <param name="serviceType">The type of the requested service.</param>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <returns>The requested service instance.</returns>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <param name="serviceType">The type of the requested service.</param>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="ifUnresolved">Says how to handle unresolved service.</param>
            <returns>The requested service instance.</returns>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,DryIoc.IfUnresolved)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <returns>The requested service instance.</returns>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved)">
            <summary>Returns instance of <typeparamref name="TService"/> searching for <paramref name="requiredServiceType"/>.
            In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
            could specify wrapped service type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="requiredServiceType">(optional) Service or wrapped type assignable to <typeparamref name="TService"/>.</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve<IEnumerable<object>>(typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Object,DryIoc.IfUnresolved,System.Type)">
            <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
            In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
            could specify wrapped service type.</summary>
            <param name="serviceType">The type of the requested service.</param>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceKey">Service key (any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/> defined).</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Service or wrapped type assignable to <paramref name="serviceType"/>.</param>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve(typeof(Lazy<object>), "someKey", requiredServiceType: typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Object,DryIoc.IfUnresolved,System.Type)">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <param name="resolver">Any <see cref="T:DryIoc.IResolver"/> implementation, e.g. <see cref="T:DryIoc.Container"/>.</param>
            <param name="serviceKey">Service key (any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/> defined).</param>
            <param name="ifUnresolved">(optional) Says how to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Service or wrapped type assignable to <typeparamref name="TService"/>.</param>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)">
            <summary>Returns all registered services instances including all keyed and default registrations.
            Use <paramref name="behavior"/> to return either all registered services at the moment of resolve (dynamic fresh view) or
            the same services that were returned with first <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)"/> call (fixed view).</summary>
            <typeparam name="TService">Return collection item type. It denotes registered service type if <paramref name="requiredServiceType"/> is not specified.</typeparam>
            <param name="resolver">Usually <see cref="T:DryIoc.Container"/> object.</param>
            <param name="requiredServiceType">(optional) Denotes registered service type. Should be assignable to <typeparamref name="TService"/>.</param>
            <param name="behavior">(optional) Specifies new registered services awareness. Aware by default.</param>
            <param name="serviceKey">(optional) Service key.</param>
            <returns>Result collection of services.</returns>
            <remarks>The same result could be achieved by directly calling:
            <code lang="cs"><![CDATA[
                container.Resolve<LazyEnumerable<IService>>();  // for dynamic result - default behavior
                container.Resolve<IService[]>();                // for fixed array
                container.Resolve<IEnumerable<IService>>();     // same as fixed array
            ]]></code>
            </remarks>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)">
            <summary>Returns all registered services as objects, including all keyed and default registrations.</summary>
            <param name="resolver">Usually <see cref="T:DryIoc.Container"/> object.</param>
            <param name="serviceType">Type of item to resolve.</param>
            <param name="behavior">(optional) Specifies new registered services awareness. Aware by default.</param>
            <param name="serviceKey">(optional) Service key.</param>
            <returns>Result collection of services.</returns>
            <returns></returns>
        </member>
        <member name="T:DryIoc.ResolveManyBehavior">
            <summary>Specifies result of <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object)"/>: either dynamic(lazy) or fixed view.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsLazyEnumerable">
            <summary>Lazy/dynamic item resolve.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsFixedArray">
            <summary>Fixed array of item at time of resolve, newly registered/removed services won't be listed.</summary>
        </member>
        <member name="T:DryIoc.IServiceInfo">
            <summary>Provides information required for service resolution: service type, 
            and optional <see cref="T:DryIoc.ServiceDetails"/>: key, what to do if service unresolved, and required service type.</summary>
        </member>
        <member name="P:DryIoc.IServiceInfo.ServiceType">
            <summary>The required piece of info: service type.</summary>
        </member>
        <member name="P:DryIoc.IServiceInfo.Details">
            <summary>Additional optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="M:DryIoc.IServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="T:DryIoc.ServiceDetails">
            <summary>Provides optional service resolution details: service key, required service type, what return when service is unresolved,
            default value if service is unresolved, custom service value.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Default">
            <summary>Default details if not specified, use default setting values, e.g. <see cref="F:DryIoc.IfUnresolved.Throw"/></summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolvedReturnDefault">
            <summary>The same as <see cref="F:DryIoc.ServiceDetails.Default"/> with only difference <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Type,System.Object,DryIoc.IfUnresolved,System.Object)">
            <summary>Creates new DTO out of provided settings, or returns default if all settings have default value.</summary>
            <param name="requiredServiceType">Registered service type to search for.</param>
            <param name="serviceKey">Service key.</param> <param name="ifUnresolved">If unresolved policy.</param>
            <param name="defaultValue">Custom default value, if specified it will automatically set <paramref name="ifUnresolved"/> to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</param>
            <returns>Created details DTO.</returns>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Object)">
            <summary>Sets custom value for service. This setting is orthogonal to the rest.</summary>
            <param name="value">Custom value.</param> <returns>Details with custom value.</returns>
        </member>
        <member name="F:DryIoc.ServiceDetails.RequiredServiceType">
            <summary>Service type to search in registry. Should be assignable to user requested service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.ServiceKey">
            <summary>Service key provided with registration.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolved">
            <summary>Policy to deal with unresolved request.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.HasCustomValue">
            <summary>Indicates that the custom value is specified.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails._value">
            <summary>Either default or custom value depending on <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> setting.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.DefaultValue">
            <summary>Value to use in case <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.CustomValue">
            <summary>Custom value specified for dependency.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.ToString">
            <summary>Pretty prints service details to string for debugging and errors.</summary> <returns>Details string.</returns>
        </member>
        <member name="T:DryIoc.ServiceInfoTools">
            <summary>Contains tools for combining or propagating of <see cref="T:DryIoc.IServiceInfo"/> independent of its concrete implementations.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithDetails``1(``0,DryIoc.ServiceDetails,DryIoc.Request)">
            <summary>Combines service info with details: the main task is to combine service and required service type.</summary>
            <typeparam name="T">Type of <see cref="T:DryIoc.IServiceInfo"/>.</typeparam>
            <param name="serviceInfo">Source info.</param> <param name="details">Details to combine with info.</param> 
            <param name="request">Owner request.</param> <returns>Original source or new combined info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.InheritInfoFromDependencyOwner(DryIoc.IServiceInfo,DryIoc.IServiceInfo,System.Boolean)">
            <summary>Enables propagation/inheritance of info between dependency and its owner: 
            for instance <see cref="F:DryIoc.ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
            <param name="dependency">Dependency info.</param>
            <param name="owner">Dependency holder/owner info.</param>
            <param name="shouldInheritServiceKey">(optional) Self-explanatory. Usually set to true for wrapper and decorator info.</param>
            <returns>Either input dependency info, or new info with properties inherited from the owner.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)">
            <summary>Appends info string representation into provided builder.</summary>
            <param name="s">String builder to print to.</param> <param name="info">Info to print.</param>
            <returns>String builder with appended info.</returns>
        </member>
        <member name="T:DryIoc.ServiceInfo">
            <summary>Represents custom or resolution root service info, there is separate representation for parameter, 
            property and field dependencies.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,DryIoc.IfUnresolved,System.Object)">
            <summary>Creates info out of provided settings</summary>
            <param name="serviceType">Service type</param>
            <param name="ifUnresolved">(optional) If unresolved policy. Set to Throw if not specified.</param>
             <param name="serviceKey">(optional) Service key.</param>
            <returns>Created info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,System.Type,DryIoc.IfUnresolved,System.Object)">
            <summary>Creates info out of provided settings</summary>
            <param name="serviceType">Service type</param>
            <param name="requiredServiceType">Registered service type to search for.</param>
            <param name="ifUnresolved">(optional) If unresolved policy. Set to Throw if not specified.</param>
             <param name="serviceKey">(optional) Service key.</param>
            <returns>Created info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Creates service info using typed <typeparamref name="TService"/>.</summary>
            <typeparam name="TService">Service type.</typeparam>
            <param name="ifUnresolved">(optional)</param> <param name="serviceKey">(optional)</param>
            <returns>Created info.</returns>
        </member>
        <member name="T:DryIoc.ServiceInfo.Typed`1">
            <summary>Strongly-typed version of Service Info.</summary> <typeparam name="TService">Service type.</typeparam>
        </member>
        <member name="M:DryIoc.ServiceInfo.Typed`1.#ctor">
            <summary>Creates service info object.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.ServiceType">
            <summary>Type of service to create. Indicates registered service in registry.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.Details">
            <summary>Additional settings. If not specified uses <see cref="F:DryIoc.ServiceDetails.Default"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="M:DryIoc.ServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.ParameterServiceInfo">
            <summary>Provides <see cref="T:DryIoc.IServiceInfo"/> for parameter, 
            by default using parameter name as <see cref="P:DryIoc.IServiceInfo.ServiceType"/>.</summary>
            <remarks>For parameter default setting <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is <see cref="F:DryIoc.IfUnresolved.Throw"/>.</remarks>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Of(System.Reflection.ParameterInfo)">
            <summary>Creates service info from parameter alone, setting service type to parameter type,
            and setting resolution policy to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> if parameter is optional.</summary>
            <param name="parameter">Parameter to create info for.</param>
            <returns>Parameter service info.</returns>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.ServiceType">
            <summary>Service type specified by <see cref="P:System.Reflection.ParameterInfo.ParameterType"/>.</summary>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.Details">
            <summary>Optional service details.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="F:DryIoc.ParameterServiceInfo.Parameter">
            <summary>Parameter info.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.PropertyOrFieldServiceInfo">
            <summary>Base class for property and field dependency info.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Of(System.Reflection.MemberInfo)">
            <summary>Create member info out of provide property or field.</summary>
            <param name="member">Member is either property or field.</param> <returns>Created info.</returns>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.ServiceType">
            <summary>The required service type. It will be either <see cref="P:System.Reflection.FieldInfo.FieldType"/> or <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>.</summary>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Details">
            <summary>Optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Member">
            <summary>Either <see cref="T:System.Reflection.PropertyInfo"/> or <see cref="T:System.Reflection.FieldInfo"/>.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.SetValue(System.Object,System.Object)">
            <summary>Sets property or field value on provided holder object.</summary>
            <param name="holder">Holder of property or field.</param> <param name="value">Value to set.</param>
        </member>
        <member name="T:DryIoc.Request">
            <summary>Contains resolution stack with information about resolved service and factory for it,
            Additionally request contain weak reference to <see cref="T:DryIoc.IContainer"/>. That the all required information for resolving services.
            Request implements <see cref="T:DryIoc.IResolver"/> interface on top of provided container, which could be use by delegate factories.</summary>
        </member>
        <member name="M:DryIoc.Request.CreateEmpty(DryIoc.ContainerWeakRef)">
            <summary>Creates empty request associated with provided <paramref name="container"/>.
            Every resolution will start from this request by pushing service information into, and then resolving it.</summary>
            <param name="container">Reference to container issued the request. Could be changed later with <see cref="M:DryIoc.Request.WithNewContainer(DryIoc.ContainerWeakRef)"/> method.</param>
            <returns>New empty request.</returns>
        </member>
        <member name="P:DryIoc.Request.IsEmpty">
            <summary>Indicates that request is empty initial request: there is no <see cref="F:DryIoc.Request._requestInfo"/> in such a request.</summary>
        </member>
        <member name="F:DryIoc.Request.RawParent">
            <summary>Request parent with all runtime info available.</summary>
        </member>
        <member name="P:DryIoc.Request.IsResolutionCall">
            <summary>Returns true if request is First in Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.IsResolutionRoot">
            <summary>Returns true if request is First in First Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.PreResolveParent">
            <summary>Request prior to Resolve call.</summary>
        </member>
        <member name="M:DryIoc.Request.IsFirstNonWrapperInResolutionCall">
            <summary>Returns true for the First Service in resolve call.</summary> <returns></returns>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFunc">
            <summary>Checks if request is wrapped in Func - where Func is one of request immediate wrappers.</summary>
            <returns>True if has Func ancestor.</returns>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFuncWithArgs">
            <summary>Checks if request has parent with service type of Func with arguments. 
            Often required to check in lazy scenarios.</summary> <returns>True if has Func with arguments ancestor.</returns>
        </member>
        <member name="P:DryIoc.Request.Parent">
            <summary>Returns service parent of request, skipping intermediate wrappers if any.</summary>
        </member>
        <member name="P:DryIoc.Request.ParentOrWrapper">
            <summary>Returns direct parent either it service or not (wrapper). 
            In comparison with logical <see cref="P:DryIoc.Request.Parent"/> which returns first service parent skipping wrapper if any.</summary>
        </member>
        <member name="M:DryIoc.Request.Ancestor(System.Func{DryIoc.RequestInfo,System.Boolean})">
            <summary>Gets first ancestor request which satisfies the condition, 
            or empty if no ancestor is found.</summary>
            <param name="condition">(optional) Condition to stop on.</param>
            <returns>Request info of found parent.</returns>
        </member>
        <member name="P:DryIoc.Request.ContainerWeakRef">
            <summary>Weak reference to container. May be replaced in request flowed from parent to child container.</summary>
        </member>
        <member name="P:DryIoc.Request.Container">
            <summary>Provides access to container currently bound to request. 
            By default it is container initiated request by calling resolve method,
            but could be changed along the way: for instance when resolving from parent container.</summary>
        </member>
        <member name="P:DryIoc.Request.Scopes">
            <summary>Separate from container because while container may be switched from parent to child, scopes should be from child/facade.</summary>
        </member>
        <member name="P:DryIoc.Request.Scope">
            <summary>Optionally associated resolution scope.</summary>
        </member>
        <member name="F:DryIoc.Request.Made">
            <summary>(optional) Made spec used for resolving request.</summary>
        </member>
        <member name="F:DryIoc.Request.FuncArgs">
            <summary>User provided arguments: key tracks what args are still unused.</summary>
            <remarks>Mutable: tracks used arguments</remarks>
        </member>
        <member name="F:DryIoc.Request.Level">
            <summary>Counting nested levels. May be used to split object graph if level is too deep.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceType">
            <summary>Requested service type.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceKey">
            <summary>Optional service key to identify service of the same type.</summary>
        </member>
        <member name="P:DryIoc.Request.IfUnresolved">
            <summary>Policy to deal with unresolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.RequiredServiceType">
            <summary>Required service type if specified.</summary>
        </member>
        <member name="P:DryIoc.Request.FactoryID">
            <summary>Implementation FactoryID.</summary>
            <remarks>The default unassigned value of ID is 0.</remarks>
        </member>
        <member name="P:DryIoc.Request.FactoryType">
            <summary>Type of factory: Service, Wrapper, or Decorator.</summary>
        </member>
        <member name="P:DryIoc.Request.ImplementationType">
            <summary>Service implementation type if known.</summary>
        </member>
        <member name="P:DryIoc.Request.Reuse">
            <summary>Service reuse.</summary>
        </member>
        <member name="P:DryIoc.Request.ReuseLifespan">
            <summary>Relative number representing reuse lifespan.</summary>
        </member>
        <member name="M:DryIoc.Request.GetActualServiceType">
            <summary>Returns result of <see cref="M:DryIoc.RequestInfo.GetActualServiceType"/>>.</summary>
            <returns>The type to be used for lookup in registry.</returns>
        </member>
        <member name="M:DryIoc.Request.Push(DryIoc.IServiceInfo,DryIoc.IScope,DryIoc.RequestInfo)">
            <summary>Creates new request with provided info, and attaches current request as new request parent.</summary>
            <param name="info">Info about service to resolve.</param> <param name="scope">(optional) Resolution scope.</param>
            <param name="preResolveParent">(optional) Request info beyond/preceding Resolve call.</param>
            <returns>New request for provided info.</returns>
            <remarks>Existing/parent request should be resolved to factory (<see cref="M:DryIoc.Request.WithResolvedFactory(DryIoc.Factory)"/>), before pushing info into it.</remarks>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.IScope,DryIoc.RequestInfo)">
            <summary>Composes service description into <see cref="T:DryIoc.IServiceInfo"/> and calls Push.</summary>
            <param name="serviceType">Service type to resolve.</param>
            <param name="serviceKey">(optional) Service key to resolve.</param>
            <param name="ifUnresolved">(optional) Instructs how to handle unresolved service.</param>
            <param name="requiredServiceType">(optional) Registered/unwrapped service type to find.</param>
            <param name="scope">(optional) Resolution scope.</param>
            <param name="preResolveParent">(optional) Request info preceding Resolve call.</param>
            <returns>New request with provided info.</returns>
        </member>
        <member name="M:DryIoc.Request.WithChangedServiceInfo(System.Func{DryIoc.IServiceInfo,DryIoc.IServiceInfo})">
            <summary>Allow to switch current service info to new one: for instance it is used be decorators.</summary>
            <param name="getInfo">Gets new info to switch to.</param>
            <returns>New request with new service info but the same implementation and context.</returns>
        </member>
        <member name="M:DryIoc.Request.ChangeServiceKey(System.Object)">
            <summary>Sets service key to passed value. Required for multiple default services to change null key to
            actual <see cref="T:DryIoc.DefaultKey"/></summary>
            <param name="serviceKey">Key to set.</param>
        </member>
        <member name="M:DryIoc.Request.WithFuncArgs(System.Type)">
            <summary>Returns new request with parameter expressions created for <paramref name="funcType"/> input arguments.
            The expression is set to <see cref="F:DryIoc.Request.FuncArgs"/> request field to use for <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>
            resolution.</summary>
            <param name="funcType">Func type to get input arguments from.</param>
            <returns>New request with <see cref="F:DryIoc.Request.FuncArgs"/> field set.</returns>
        </member>
        <member name="M:DryIoc.Request.WithNewContainer(DryIoc.ContainerWeakRef)">
            <summary>Changes container to passed one. Could be used by child container, 
            to switch child container to parent preserving the rest of request state.</summary>
            <param name="newContainer">Reference to container to switch to.</param>
            <returns>Request with replaced container.</returns>
        </member>
        <member name="M:DryIoc.Request.WithResolvedFactory(DryIoc.Factory)">
            <summary>Returns new request with set implementation details.</summary>
            <param name="factory">Factory to which request is resolved.</param>
            <returns>New request with set factory.</returns>
        </member>
        <member name="M:DryIoc.Request.GetParentOrFuncOrEmpty(System.Boolean)">
            <summary>Returns non-wrapper parent of Func wrapper if any.</summary>
            <param name="firstNonTransientParent">(optional) When set specifies to search for first not transient parent.</param>
            <returns>Found parent or Func parent or empty.</returns>
        </member>
        <member name="M:DryIoc.Request.ToRequestInfo">
            <summary>Converts input request into its serializable version stripped from run-time info.</summary>
            <returns>Mirrored request info.</returns>
        </member>
        <member name="M:DryIoc.Request.Is``1(System.Func{``0},System.Func{System.Reflection.ParameterInfo,``0},System.Func{System.Reflection.PropertyInfo,``0},System.Func{System.Reflection.FieldInfo,``0})">
            <summary>If request corresponds to dependency injected into parameter, 
            then method calls <paramref name="parameter"/> handling and returns its result.
            If request corresponds to property or field, then method calls respective handler.
            If request does not correspond to dependency, then calls <paramref name="root"/> handler.</summary>
            <typeparam name="TResult"></typeparam>
            <param name="root">(optional) handler for resolution call or root.</param>
            <param name="parameter">(optional) handler for parameter dependency</param>
            <param name="property">(optional) handler for property dependency</param>
            <param name="field">(optional) handler for field dependency</param>
            <returns>Result of applied handler or default <typeparamref name="TResult"/>.</returns>
        </member>
        <member name="M:DryIoc.Request.Enumerate">
            <summary>Enumerates all request stack parents. 
            Last returned will <see cref="P:DryIoc.Request.IsEmpty"/> empty parent.</summary>
            <returns>Unfolding parents.</returns>
        </member>
        <member name="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)">
            <summary>Prints current request info only (no parents printed) to provided builder.</summary>
            <param name="s">Builder to print too.</param>
            <returns>(optional) Builder to appended info to, or new builder if not specified.</returns>
        </member>
        <member name="M:DryIoc.Request.Print(System.Int32)">
            <summary>Prints full stack of requests starting from current one using <see cref="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)"/>.</summary>
            <param name="recursiveFactoryID">Flag specifying that in case of found recursion/repetition of requests, 
            mark repeated requests.</param>
            <returns>Builder with appended request stack info.</returns>
        </member>
        <member name="M:DryIoc.Request.ToString">
            <summary>Print while request stack info to string using <seealso cref="M:DryIoc.Request.Print(System.Int32)"/>.</summary>
            <returns>String with info.</returns>
        </member>
        <member name="T:DryIoc.FactoryType">
            <summary>Type of services supported by Container.</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Service">
            <summary>(default) Defines normal service factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Decorator">
            <summary>Defines decorator factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Wrapper">
            <summary>Defines wrapper factory.</summary>
        </member>
        <member name="T:DryIoc.Setup">
            <summary>Base class to store optional <see cref="T:DryIoc.Factory"/> settings.</summary>
        </member>
        <member name="P:DryIoc.Setup.FactoryType">
            <summary>Factory type is required to be specified by concrete setups as in 
            <see cref="T:DryIoc.Setup.ServiceSetup"/>, <see cref="T:DryIoc.Setup.DecoratorSetup"/>, <see cref="T:DryIoc.Setup.WrapperSetup"/>.</summary>
        </member>
        <member name="P:DryIoc.Setup.Condition">
            <summary>Predicate to check if factory could be used for resolved request.</summary>
        </member>
        <member name="P:DryIoc.Setup.Metadata">
            <summary>Arbitrary metadata object associated with Factory/Implementation.</summary>
        </member>
        <member name="P:DryIoc.Setup.AsResolutionCall">
            <summary>Indicates that injected expression should be: 
            <c><![CDATA[r.Resolver.Resolve<IDependency>(...)]]></c>
            instead of: <c><![CDATA[new Dependency(...)]]></c></summary>
        </member>
        <member name="P:DryIoc.Setup.AsResolutionRoot">
            <summary>Marks service (not a wrapper or decorator) registration that is expected to be resolved via Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Setup.OpenResolutionScope">
            <summary>In addition to <see cref="P:DryIoc.Setup.AsResolutionCall"/> opens scope.</summary>
        </member>
        <member name="P:DryIoc.Setup.PreventDisposal">
            <summary>Prevents disposal of reused instance if it is disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.WeaklyReferenced">
            <summary>Stores reused instance as WeakReference.</summary>
        </member>
        <member name="P:DryIoc.Setup.AllowDisposableTransient">
            <summary>Allows registering transient disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.TrackDisposableTransient">
            <summary>Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</summary>
        </member>
        <member name="P:DryIoc.Setup.UseParentReuse">
            <summary>Instructs to use parent reuse. Applied only if <see cref="F:DryIoc.Factory.Reuse"/> is not specified.</summary>
        </member>
        <member name="F:DryIoc.Setup.Default">
            <summary>Default setup for service factories.</summary>
        </member>
        <member name="M:DryIoc.Setup.With(System.Object,System.Func{DryIoc.RequestInfo,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Constructs setup object out of specified settings. If all settings are default then <see cref="F:DryIoc.Setup.Default"/> setup will be returned.</summary>
            <param name="metadataOrFuncOfMetadata">(optional) Metadata object or Func returning metadata object.</param> <param name="condition">(optional)</param>
            <param name="openResolutionScope">(optional) Same as <paramref name="asResolutionCall"/> but in addition opens new scope.</param>
            <param name="asResolutionCall">(optional) If true dependency expression will be "r.Resolve(...)" instead of inline expression.</param>
            <param name="asResolutionRoot">(optional) Marks service (not a wrapper or decorator) registration that is expected to be resolved via Resolve call.</param>
            <param name="preventDisposal">(optional) Prevents disposal of reused instance if it is disposable.</param>
            <param name="weaklyReferenced">(optional) Stores reused instance as WeakReference.</param>
            <param name="allowDisposableTransient">(optional) Allows registering transient disposable.</param>
            <param name="trackDisposableTransient">(optional) Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</param>
            <param name="useParentReuse">(optional) Instructs to use parent reuse. Applied only if <see cref="F:DryIoc.Factory.Reuse"/> is not specified.</param>
            <returns>New setup object or <see cref="F:DryIoc.Setup.Default"/>.</returns>
        </member>
        <member name="F:DryIoc.Setup.Wrapper">
            <summary>Default setup which will look for wrapped service type as single generic parameter.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperWith(System.Int32,System.Boolean)">
            <summary>Returns generic wrapper setup.</summary>
            <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument. Need to be set for multiple type arguments.</param> 
            <param name="alwaysWrapsRequiredServiceType">Need to be set when generic wrapper type arguments should be ignored.</param>
            <returns>New setup or default <see cref="F:DryIoc.Setup.Wrapper"/>.</returns>
        </member>
        <member name="F:DryIoc.Setup.Decorator">
            <summary>Default decorator setup: decorator is applied to service type it registered with.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorWith(System.Func{DryIoc.RequestInfo,System.Boolean},System.Int32,System.Boolean)">
            <summary>Creates setup with optional condition.</summary>
            <param name="condition">(optional) Applied to decorated service to find that service is the decorator target.</param>
            <param name="order">(optional) If provided specifies relative decorator position in decorators chain.</param>
            <param name="useDecorateeReuse">If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order 
            - first registered are closer decoratee.</param>
            <returns>New setup with condition or <see cref="F:DryIoc.Setup.Decorator"/>.</returns>
        </member>
        <member name="P:DryIoc.Setup.ServiceSetup.Metadata">
            <summary>Evaluates metadata if it specified as Func of object, and replaces Func with its result!.
            Otherwise just returns metadata object.</summary>
            <remarks>Invocation of Func metadata is Not thread-safe. Please take care of that inside the Func.</remarks>
        </member>
        <member name="T:DryIoc.Setup.WrapperSetup">
            <summary>Setup for <see cref="F:DryIoc.FactoryType.Wrapper"/> factory.</summary>
        </member>
        <member name="P:DryIoc.Setup.WrapperSetup.FactoryType">
            <summary>Returns <see cref="F:DryIoc.FactoryType.Wrapper"/> type.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.WrappedServiceTypeArgIndex">
            <summary>Delegate to get wrapped type from provided wrapper type. 
            If wrapper is generic, then wrapped type is usually a generic parameter.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.AlwaysWrapsRequiredServiceType">
            <summary>Per name.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32,System.Boolean)">
            <summary>Constructs wrapper setup from optional wrapped type selector and reuse wrapper factory.</summary>
            <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument. Need to be set for multiple type arguments.</param> 
            <param name="alwaysWrapsRequiredServiceType">Need to be set when generic wrapper type arguments should be ignored.</param>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.GetWrappedTypeOrNullIfWrapsRequired(System.Type)">
            <summary>Unwraps service type or returns its.</summary>
            <param name="serviceType"></param> <returns>Wrapped type or self.</returns>
        </member>
        <member name="T:DryIoc.Setup.DecoratorSetup">
            <summary>Setup applied to decorators.</summary>
        </member>
        <member name="P:DryIoc.Setup.DecoratorSetup.FactoryType">
            <summary>Returns Decorator factory type.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.Order">
            <summary>If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order 
            - first registered are closer decoratee.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.UseDecorateeReuse">
            <summary>Instructs to use decorated service reuse. Decorated service may be decorator itself.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorSetup.#ctor(System.Func{DryIoc.RequestInfo,System.Boolean},System.Int32,System.Boolean)">
            <summary>Creates decorator setup with optional condition.</summary>
            <param name="condition">(optional) Applied to decorated service to find that service is the decorator target.</param>
            <param name="order">(optional) If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order 
            - first registered are closer decoratee.</param>
            <param name="useDecorateeReuse">(optional) Instructs to use decorated service reuse.
            Decorated service may be decorator itself.</param>
        </member>
        <member name="T:DryIoc.IConcreteFactoryGenerator">
            <summary>Facility for creating concrete factories from some template/prototype. Example: 
            creating closed-generic type reflection factory from registered open-generic prototype factory.</summary>
        </member>
        <member name="P:DryIoc.IConcreteFactoryGenerator.GeneratedFactories">
            <summary>Generated factories so far, identified by the service type and key pair.</summary>
        </member>
        <member name="M:DryIoc.IConcreteFactoryGenerator.GetGeneratedFactoryOrDefault(DryIoc.Request)">
            <summary>Returns factory per request. May track already generated factories and return one without regenerating.</summary>
            <param name="request">Request to resolve.</param> <returns>Returns new factory per request.</returns>
        </member>
        <member name="T:DryIoc.Factory">
            <summary>Base class for different ways to instantiate service: 
            <list type="bullet">
            <item>Through reflection - <see cref="T:DryIoc.ReflectionFactory"/></item>
            <item>Using custom delegate - <see cref="T:DryIoc.DelegateFactory"/></item>
            <item>Using custom expression - <see cref="T:DryIoc.ExpressionFactory"/></item>
            </list>
            For all of the types Factory should provide result as <see cref="T:System.Linq.Expressions.Expression"/> and <see cref="T:DryIoc.FactoryDelegate"/>.
            Factories are supposed to be immutable and stateless.
            Each created factory has an unique ID set in <see cref="P:DryIoc.Factory.FactoryID"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.FactoryID">
            <summary>Unique factory id generated from static seed.</summary>
        </member>
        <member name="F:DryIoc.Factory.Reuse">
            <summary>Reuse policy for factory created services.</summary>
        </member>
        <member name="P:DryIoc.Factory.Setup">
            <summary>Setup may contain different/non-default factory settings.</summary>
        </member>
        <member name="M:DryIoc.Factory.CheckCondition(DryIoc.Request)">
            <summary>Checks that condition is met for request or there is no condition setup. 
            Additionally check for reuse scope availability.</summary>
            <param name="request">Request to check against.</param>
            <returns>True if condition met or no condition setup.</returns>
        </member>
        <member name="P:DryIoc.Factory.FactoryType">
            <summary>Shortcut for <see cref="P:DryIoc.Setup.FactoryType"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.ImplementationType">
            <summary>Non-abstract closed implementation type. May be null if not known beforehand, e.g. in <see cref="T:DryIoc.DelegateFactory"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.FactoryGenerator">
            <summary>Indicates that Factory is factory provider and 
            consumer should call <see cref="M:DryIoc.IConcreteFactoryGenerator.GetGeneratedFactoryOrDefault(DryIoc.Request)"/>  to get concrete factory.</summary>
        </member>
        <member name="M:DryIoc.Factory.GetNextID">
            <summary>Get next factory ID in a atomic way.</summary><returns>The ID.</returns>
        </member>
        <member name="M:DryIoc.Factory.#ctor(DryIoc.IReuse,DryIoc.Setup)">
            <summary>Initializes reuse and setup. Sets the <see cref="P:DryIoc.Factory.FactoryID"/></summary>
            <param name="reuse">(optional)</param>
            <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.Factory.HasMatchingReuseScope(DryIoc.Request)">
            <summary>Returns true if for factory Reuse exists matching resolution or current Scope.</summary>
            <param name="request"></param> <returns>True if matching Scope exists.</returns>
        </member>
        <member name="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>The main factory method to create service expression, e.g. "new Client(new Service())".
            If <paramref name="request"/> has <see cref="F:DryIoc.Request.FuncArgs"/> specified, they could be used in expression.</summary>
            <param name="request">Service request.</param>
            <returns>Created expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.IsFactoryExpressionCacheable(DryIoc.Request)">
            <summary>Allows derived factories to override or reuse caching policy used by
            GetExpressionOrDefault. By default only service setup and no  user passed arguments may be cached.</summary>
            <param name="request">Context.</param> <returns>True if factory expression could be cached.</returns>
        </member>
        <member name="M:DryIoc.Factory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Returns service expression: either by creating it with <see cref="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)"/> or taking expression from cache.
            Before returning method may transform the expression  by applying <see cref="F:DryIoc.Factory.Reuse"/>, or/and decorators if found any.</summary>
            <param name="request">Request for service.</param> <returns>Service expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.ApplyReuse(System.Linq.Expressions.Expression,DryIoc.IReuse,System.Boolean,DryIoc.Request)">
            <summary>Applies reuse to created expression. 
            Actually wraps passed expression in scoped access and produces another expression.</summary>
            <param name="serviceExpr">Raw service creation (or receiving) expression.</param>
            <param name="reuse">Reuse - may be different from <see cref="F:DryIoc.Factory.Reuse"/> if set <see cref="P:DryIoc.Rules.DefaultReuseInsteadOfTransient"/>.</param>
            <param name="tracksTransientDisposable">Specifies that reuse is to track transient disposable.</param>
            <param name="request">Context.</param>
            <returns>Scoped expression or originally passed expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.ThrowIfReuseHasShorterLifespanThanParent(DryIoc.IReuse,DryIoc.Request)">
            <summary>Throws if request direct or further ancestor has longer reuse lifespan,
            and throws if that is true. Until there is a Func wrapper in between.</summary> 
            <param name="reuse">Reuse to check.</param> <param name="request">Request to resolve.</param>
        </member>
        <member name="M:DryIoc.Factory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>Creates factory delegate from service expression and returns it.
            to compile delegate from expression but could be overridden by concrete factory type: e.g. <see cref="T:DryIoc.DelegateFactory"/></summary>
            <param name="request">Service request.</param>
            <returns>Factory delegate created from service expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.ToString">
            <summary>Returns nice string representation of factory.</summary>
            <returns>String representation.</returns>
        </member>
        <member name="T:DryIoc.FactoryMethodSelector">
            <summary>Declares delegate to get single factory method or constructor for resolved request.</summary>
            <param name="request">Request to resolve.</param>
            <returns>Factory method wrapper over constructor or method.</returns>
        </member>
        <member name="T:DryIoc.ParameterSelector">
            <summary>Specifies how to get parameter info for injected parameter and resolved request</summary>
            <remarks>Request is for parameter method owner not for parameter itself.</remarks>
            <param name="request">Request for parameter method/constructor owner.</param>
            <returns>Service info describing how to inject parameter.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFieldsSelector">
            <summary>Specifies what properties or fields to inject and how.</summary>
            <param name="request">Request for property/field owner.</param>
            <returns>Corresponding service info for each property/field to be injected.</returns>
        </member>
        <member name="T:DryIoc.Parameters">
            <summary>DSL for specifying <see cref="T:DryIoc.ParameterSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.Parameters.Of">
            <summary>Specifies to return default details <see cref="F:DryIoc.ServiceDetails.Default"/> for all parameters.</summary>
        </member>
        <member name="M:DryIoc.Parameters.And(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Combines source selector with other. Other will override the source.</summary>
            <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
            <returns>Combined result selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Details(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Overrides source parameter rules with specific parameter details. If it is not your parameter just return null.</summary>
            <param name="source">Original parameters rules</param> 
            <param name="getDetailsOrNull">Should return specific details or null.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by <paramref name="name"/>.</summary>
            <param name="source">Original parameters rules.</param> <param name="name">Name to identify parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by name and set custom value to it.</summary>
            <param name="source">Original parameters rules.</param> <param name="name">Parameter name.</param>
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Type,System.Object,DryIoc.IfUnresolved,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <typeparamref name="T"/>.</summary>
            <typeparam name="T">Type of parameter.</typeparam> <param name="source">Source selector.</param> 
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Func{DryIoc.Request,``0})">
            <summary>Specify parameter by type and set custom value to it.</summary>
            <typeparam name="T">Parameter type.</typeparam>
            <param name="source">Original parameters rules.</param> 
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFields">
            <summary>DSL for specifying <see cref="T:DryIoc.PropertiesAndFieldsSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Of">
            <summary>Say to not resolve any properties or fields.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Auto">
            <summary>Public assignable instance members of any type except object, string, primitives types, and arrays of those.</summary>
        </member>
        <member name="T:DryIoc.PropertiesAndFields.GetInfo">
            <summary>Should return service info for input member (property or field).</summary>
            <param name="member">Input member.</param> <param name="request">Request to provide context.</param> <returns>Service info.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.All(System.Boolean,System.Boolean,System.Boolean,DryIoc.IfUnresolved,DryIoc.PropertiesAndFields.GetInfo)">
            <summary>Generates selector property and field selector with settings specified by parameters.
            If all parameters are omitted the return all public not primitive members.</summary>
            <param name="withNonPublic">(optional) Specifies to include non public members. Will include by default.</param>
            <param name="withPrimitive">(optional) Specifies to include members of primitive types. Will include by default.</param>
            <param name="withFields">(optional) Specifies to include fields as well as properties. Will include by default.</param>
            <param name="ifUnresolved">(optional) Defines ifUnresolved behavior for resolved members.</param>
            <param name="withInfo">(optional) Return service info for a member or null to skip member resolution.</param>
            <returns>Result selector composed using provided settings.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Combines source properties and fields with other. Other will override the source condition.</summary>
            <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
            <returns>Combined result selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Details(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,DryIoc.ServiceDetails})">
            <summary>Specifies service details (key, if-unresolved policy, required type) for property/field with the name.</summary>
            <param name="source">Original member selector.</param> <param name="name">Member name.</param> <param name="getDetails">Details.</param>
            <returns>New selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for property/field identified by <paramref name="name"/>.</summary>
            <param name="source">Source selector.</param> <param name="name">Name to identify member.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default returns default value if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specifies custom value for property/field with specific name.</summary>
            <param name="source">Original property/field list.</param>
            <param name="name">Target member name.</param> <param name="getCustomValue">Custom value provider.</param>
            <returns>Return new combined selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if property matches flags provided.</summary>
            <param name="property">Property to match</param>
            <param name="withNonPublic">Says to include non public properties.</param>
            <param name="withPrimitive">Says to include properties of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.FieldInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if field matches flags provided.</summary>
            <param name="field">Field to match.</param>
            <param name="withNonPublic">Says to include non public fields.</param>
            <param name="withPrimitive">Says to include fields of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="T:DryIoc.ReflectionFactory">
            <summary>Reflects on <see cref="P:DryIoc.ReflectionFactory.ImplementationType"/> constructor parameters and members,
            creates expression for each reflected dependency, and composes result service expression.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.ImplementationType">
            <summary>Non-abstract service implementation type. May be open generic.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.FactoryGenerator">
            <summary>Provides closed-generic factory for registered open-generic variant.</summary>
        </member>
        <member name="F:DryIoc.ReflectionFactory.Made">
            <summary>Injection rules set for Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor(System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
            <param name="implementationType">(optional) Optional if Made.FactoryMethod is present Non-abstract close or open generic type.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.ReflectionFactory.IsFactoryExpressionCacheable(DryIoc.Request)">
            <summary>Add to base rules: do not cache if Made is context based.</summary>
            <param name="request">Context.</param> <returns>True if factory expression could be cached.</returns>
        </member>
        <member name="M:DryIoc.ReflectionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression, so for registered implementation type "Service", 
            you will get "new Service()". If there is <see cref="T:DryIoc.Reuse"/> specified, then expression will
            contain call to <see cref="T:DryIoc.Scope"/> returned by reuse.</summary>
            <param name="request">Request for service to resolve.</param> <returns>Created expression.</returns>
        </member>
        <member name="T:DryIoc.ExpressionFactory">
            <summary>Creates service expression using client provided expression factory delegate.</summary>
        </member>
        <member name="M:DryIoc.ExpressionFactory.#ctor(System.Func{DryIoc.Request,System.Linq.Expressions.Expression},DryIoc.IReuse,DryIoc.Setup)">
            <summary>Wraps provided delegate into factory.</summary>
            <param name="getServiceExpression">Delegate that will be used internally to create service expression.</param>
            <param name="reuse">(optional) Reuse.</param> <param name="setup">(optional) Setup.</param>
        </member>
        <member name="M:DryIoc.ExpressionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression using wrapped delegate.</summary>
            <param name="request">Request to resolve.</param> <returns>Expression returned by stored delegate.</returns>
        </member>
        <member name="T:DryIoc.InstanceFactory">
            <summary>Factory representing external service object registered with <see cref="M:DryIoc.Registrator.RegisterInstance(DryIoc.IContainer,System.Type,System.Object,DryIoc.IReuse,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)"/>.</summary>
        </member>
        <member name="P:DryIoc.InstanceFactory.ImplementationType">
            <summary>Instance type, or null for null instance.</summary>
        </member>
        <member name="M:DryIoc.InstanceFactory.#ctor(System.Object,DryIoc.IReuse,DryIoc.Setup)">
            <summary>Creates factory wrapping provided instance.</summary>
            <param name="instance">Instance to register.</param>
            <param name="reuse"></param> <param name="setup"></param>
        </member>
        <member name="M:DryIoc.InstanceFactory.ReplaceInstance(System.Object)">
            <summary>Replaces current instance with new one.</summary> <param name="newInstance"></param>
        </member>
        <member name="M:DryIoc.InstanceFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>The method should not be really called. That's why it returns exception throwing expression.</summary>
            <param name="request">Context</param> <returns>Expression throwing exception.</returns>
        </member>
        <member name="M:DryIoc.InstanceFactory.ApplyReuse(System.Linq.Expressions.Expression,DryIoc.IReuse,System.Boolean,DryIoc.Request)">
            <summary>Puts instance directly to available scope.</summary>
        </member>
        <member name="T:DryIoc.DelegateFactory">
            <summary>This factory is the thin wrapper for user provided delegate 
            and where possible it uses delegate directly: without converting it to expression.</summary>
        </member>
        <member name="P:DryIoc.DelegateFactory.ImplementationType">
            <summary>Non-abstract closed implementation type.</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.#ctor(System.Func{DryIoc.IResolver,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Type)">
            <summary>Creates factory by providing:</summary>
            <param name="factoryDelegate">Specified service creation delegate.</param>
            <param name="reuse">(optional) Reuse behavior for created service.</param>
            <param name="setup">(optional) Additional settings.</param>
            <param name="knownImplementationType">(optional) Implementation type if known, e.g. when registering existing instance.</param>
        </member>
        <member name="M:DryIoc.DelegateFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Create expression by wrapping call to stored delegate with provided request.</summary>
            <param name="request">Request to resolve. It will be stored in resolution state to be passed to delegate on actual resolve.</param>
            <returns>Created delegate call expression.</returns>
        </member>
        <member name="M:DryIoc.DelegateFactory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>If possible returns delegate directly, without creating expression trees, just wrapped in <see cref="T:DryIoc.FactoryDelegate"/>.
            If decorator found for request then factory fall-backs to expression creation.</summary>
            <param name="request">Request to resolve.</param> 
            <returns>Factory delegate directly calling wrapped delegate, or invoking expression if decorated.</returns>
        </member>
        <member name="T:DryIoc.CreateScopedValue">
            <summary>Should return value stored in scope.</summary>
        </member>
        <member name="T:DryIoc.IScope">
            <summary>Lazy object storage that will create object with provided factory on first access, 
            then will be returning the same object for subsequent access.</summary>
        </member>
        <member name="P:DryIoc.IScope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.IScope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)">
            <summary>Creates, stores, and returns stored object.</summary>
            <param name="id">Unique ID to find created object in subsequent calls.</param>
            <param name="createValue">Delegate to create object. It will be used immediately, and reference to delegate will not be stored.</param>
            <returns>Created and stored object.</returns>
            <remarks>Scope does not store <paramref name="createValue"/> (no memory leak here), 
            it stores only result of <paramref name="createValue"/> call.</remarks>
        </member>
        <member name="M:DryIoc.IScope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at.</param> <param name="item">Value to set.</param>
        </member>
        <member name="M:DryIoc.IScope.GetScopedItemIdOrSelf(System.Int32)">
            <summary>Creates id/index for new item to be stored in scope. 
            If separate index is not supported then just returns back passed <paramref name="externalId"/>.</summary>
            <param name="externalId">Id to be mapped to new item id/index</param> 
            <returns>New it/index or just passed <paramref name="externalId"/></returns>
        </member>
        <member name="T:DryIoc.Scope">
            <summary>Scope implementation which will dispose stored <see cref="T:System.IDisposable"/> items on its own dispose.
            Locking is used internally to ensure that object factory called only once.</summary>
        </member>
        <member name="P:DryIoc.Scope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="M:DryIoc.Scope.#ctor(DryIoc.IScope,System.Object)">
            <summary>Create scope with optional parent and name.</summary>
            <param name="parent">Parent in scope stack.</param> <param name="name">Associated name object.</param>
        </member>
        <member name="M:DryIoc.Scope.GetScopedItemIdOrSelf(System.Int32)">
            <summary>Just returns back <paramref name="externalId"/> without any changes.</summary>
            <param name="externalId">Id will be returned back.</param> <returns><paramref name="externalId"/>.</returns>
        </member>
        <member name="M:DryIoc.Scope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)">
            <summary><see cref="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)"/> for description.
            Will throw <see cref="T:DryIoc.ContainerException"/> if scope is disposed.</summary>
            <param name="id">Unique ID to find created object in subsequent calls.</param>
            <param name="createValue">Delegate to create object. It will be used immediately, and reference to delegate will Not be stored.</param>
            <returns>Created and stored object.</returns>
            <exception cref="T:DryIoc.ContainerException">if scope is disposed.</exception>
        </member>
        <member name="M:DryIoc.Scope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at.</param> <param name="item">Value to set.</param>
        </member>
        <member name="M:DryIoc.Scope.Dispose">
            <summary>Disposes all stored <see cref="T:System.IDisposable"/> objects and nullifies object storage.</summary>
            <remarks>If item disposal throws exception, then it won't be propagated outside, 
            so the rest of the items could be disposed.</remarks>
        </member>
        <member name="M:DryIoc.Scope.ToString">
            <summary>Prints scope info (name and parent) to string for debug purposes.</summary> 
            <returns>String representation.</returns>
        </member>
        <member name="T:DryIoc.SingletonScope">
            <summary>Different from <see cref="T:DryIoc.Scope"/> so that uses single array of items for fast access.
            The array structure is:
            items[0] is reserved for storing object[][] buckets.
            items[1-BucketSize] are used for storing actual singletons up to (BucketSize-1) index
            Buckets structure is variable number of object[BucketSize] buckets used to storing items with index >= BucketSize.
            The structure allows very fast access to up to <see cref="F:DryIoc.SingletonScope.BucketSize"/> singletons - it just array access: items[itemIndex]
            For further indexes it is a fast O(1) access: ((object[][])items[i])[i / BucketSize - 1][i % BucketSize]
            </summary>
        </member>
        <member name="P:DryIoc.SingletonScope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.SingletonScope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="F:DryIoc.SingletonScope.BucketSize">
            <summary>Amount of items in item array.</summary>
        </member>
        <member name="M:DryIoc.SingletonScope.#ctor(DryIoc.IScope,System.Object)">
            <summary>Creates scope.</summary>
            <param name="parent">Parent in scope stack.</param> <param name="name">Associated name object.</param>
        </member>
        <member name="M:DryIoc.SingletonScope.GetScopedItemIdOrSelf(System.Int32)">
            <summary>Adds mapping between provide id and index for new stored item. Returns index.</summary>
            <param name="externalId">External id mapped to internal index.</param>
            <returns>Already mapped index, or newly created.</returns>
        </member>
        <member name="M:DryIoc.SingletonScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)">
            <summary><see cref="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue)"/> for description.
            Will throw <see cref="T:DryIoc.ContainerException"/> if scope is disposed.</summary>
            <param name="id">Unique ID to find created object in subsequent calls.</param>
            <param name="createValue">Delegate to create object. It will be used immediately, and reference to delegate will Not be stored.</param>
            <returns>Created and stored object.</returns>
            <exception cref="T:DryIoc.ContainerException">if scope is disposed.</exception>
        </member>
        <member name="M:DryIoc.SingletonScope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at.</param> <param name="item">Value to set.</param>
        </member>
        <member name="M:DryIoc.SingletonScope.GetOrAdd(System.Object)">
            <summary>Adds external non-service item into singleton collection. 
            The item may not have corresponding external item ID.</summary>
            <param name="item">External item to add, this may be metadata, service key, etc.</param>
            <returns>Index of added or already added item.</returns>
        </member>
        <member name="M:DryIoc.SingletonScope.Dispose">
            <summary>Disposes all stored <see cref="T:System.IDisposable"/> objects and nullifies object storage.</summary>
            <remarks>If item disposal throws exception, then it won't be propagated outside, so the rest of the items could be disposed.</remarks>
        </member>
        <member name="F:DryIoc.SingletonScope.Items">
            <summary>value at 0 index is reserved for [][] structure to accommodate more values</summary>
        </member>
        <member name="T:DryIoc.SetCurrentScopeHandler">
            <summary>Delegate to get new scope from old/existing current scope.</summary>
            <param name="oldScope">Old/existing scope to change.</param>
            <returns>New scope or old if do not want to change current scope.</returns>
        </member>
        <member name="T:DryIoc.IScopeContext">
            <summary>Provides ambient current scope and optionally scope storage for container, 
            examples are HttpContext storage, Execution context, Thread local.</summary>
        </member>
        <member name="P:DryIoc.IScopeContext.RootScopeName">
            <summary>Name associated with context root scope - so the reuse may find scope context.</summary>
        </member>
        <member name="M:DryIoc.IScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
            <returns>Current scope or null.</returns>
        </member>
        <member name="M:DryIoc.IScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Changes current scope using provided delegate. Delegate receives current scope as input and
            should return new current scope.</summary>
            <param name="setCurrentScope">Delegate to change the scope.</param>
            <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
            <returns>New current scope. So it is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
        </member>
        <member name="T:DryIoc.ThreadScopeContext">
            <summary>Tracks one current scope per thread, so the current scope in different tread would be different or null,
            if not yet tracked. Context actually stores scope references internally, so it should be disposed to free them.</summary>
        </member>
        <member name="F:DryIoc.ThreadScopeContext.ScopeContextName">
            <summary>Provides static name for context. It is OK because its constant.</summary>
        </member>
        <member name="P:DryIoc.ThreadScopeContext.RootScopeName">
            <summary>Key to identify context.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope in calling Thread or null, if no scope tracked.</summary>
            <returns>Found scope or null.</returns>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Change current scope for the calling Thread.</summary>
            <param name="setCurrentScope">Delegate to change the scope given current one (or null).</param>
            <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.Dispose">
            <summary>Disposed all stored/tracked scopes and empties internal scope storage.</summary>
        </member>
        <member name="T:DryIoc.IReuse">
            <summary>Reuse goal is to locate or create scope where reused objects will be stored.</summary>
            <remarks><see cref="T:DryIoc.IReuse"/> implementors supposed to be stateless, and provide scope location behavior only.
            The reused service instances should be stored in scope(s).</remarks>
        </member>
        <member name="P:DryIoc.IReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="M:DryIoc.IReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Locates or creates scope to store reused service objects.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Located scope.</returns>
        </member>
        <member name="M:DryIoc.IReuse.GetScopeExpression(DryIoc.Request)">
            <summary>Supposed to create in-line expression with the same code as body of <see cref="M:DryIoc.IReuse.GetScopeOrDefault(DryIoc.Request)"/> method.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Expression of type <see cref="T:DryIoc.IScope"/>.</returns>
            <remarks>Result expression should be static: should Not create closure on any objects. 
            If you require to reference some item from outside, put it into <see cref="P:DryIoc.IContainer.ResolutionStateCache"/>.</remarks>
        </member>
        <member name="M:DryIoc.IReuse.GetScopedItemIdOrSelf(System.Int32,DryIoc.Request)">
            <summary>Returns special id/index to lookup scoped item, or original passed factory id otherwise.</summary>
            <param name="factoryID">Id to map to item id/index.</param> <param name="request">Context to get access to scope.</param>
            <returns>id/index or source factory id.</returns>
        </member>
        <member name="T:DryIoc.SingletonReuse">
            <summary>Returns container bound scope for storing singleton objects.</summary>
        </member>
        <member name="P:DryIoc.SingletonReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Returns container bound Singleton scope.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Container singleton scope.</returns>
        </member>
        <member name="M:DryIoc.SingletonReuse.GetScopeExpression(DryIoc.Request)">
            <summary>Returns expression directly accessing <see cref="P:DryIoc.IScopeAccess.SingletonScope"/>.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Singleton scope property expression.</returns>
        </member>
        <member name="M:DryIoc.SingletonReuse.GetScopedItemIdOrSelf(System.Int32,DryIoc.Request)">
            <summary>Returns index of new item in singleton scope.</summary>
            <param name="factoryID">Factory id to map to new item index.</param>
            <param name="request">Context to get singleton scope from.</param>
            <returns>Index in scope.</returns>
        </member>
        <member name="M:DryIoc.SingletonReuse.ToString">
            <summary>Pretty prints reuse name and lifespan</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.CurrentScopeReuse">
            <summary>Returns container bound current scope created by <see cref="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/> method.</summary>
            <remarks>It is the same as Singleton scope if container was not created by <see cref="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/>.</remarks>
        </member>
        <member name="F:DryIoc.CurrentScopeReuse.Name">
            <summary>Name to find current scope or parent with equal name.</summary>
        </member>
        <member name="P:DryIoc.CurrentScopeReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.#ctor(System.Object)">
            <summary>Creates reuse optionally specifying its name.</summary> 
            <param name="name">(optional) Used to find matching current scope or parent.</param>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Returns container current scope or if <see cref="F:DryIoc.CurrentScopeReuse.Name"/> specified: current scope or its parent with corresponding name.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Found current scope or its parent.</returns>
            <exception cref="T:DryIoc.ContainerException">with the code <see cref="F:DryIoc.Error.NoMatchedScopeFound"/> if <see cref="F:DryIoc.CurrentScopeReuse.Name"/> specified but
            no matching scope or its parent found.</exception>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopeExpression(DryIoc.Request)">
            <summary>Returns <see cref="M:DryIoc.IScopeAccess.GetCurrentNamedScope(System.Object,System.Boolean)"/> method call expression.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Method call expression returning matched current scope.</returns>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedItemIdOrSelf(System.Int32,DryIoc.Request)">
            <summary>Asks the scope to convert factory ID into internal representation and returns it.
            If scope is not available then return passed factory ID.</summary>
            <param name="factoryID">Input factory ID.</param> <param name="request">Used to get scope back.</param>
            <returns>Scope mapping of factory ID or passed factory ID without changes if scope is not available.</returns>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToString">
            <summary>Pretty prints reuse to string.</summary> <returns>Reuse string.</returns>
        </member>
        <member name="T:DryIoc.ResolutionScopeReuse">
            <summary>Represents services created once per resolution root (when some of Resolve methods called).</summary>
            <remarks>Scope is created only if accessed to not waste memory.</remarks>
        </member>
        <member name="P:DryIoc.ResolutionScopeReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeReuse.AssignableFromServiceType">
            <summary>Indicates consumer with assignable service type that defines resolution scope.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeReuse.ServiceKey">
            <summary>Indicates service key of the consumer that defines resolution scope.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeReuse.Outermost">
            <summary>When set indicates to find the outermost matching consumer with resolution scope,
            otherwise nearest consumer scope will be used.</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.#ctor(System.Type,System.Object,System.Boolean)">
            <summary>Creates new resolution scope reuse with specified type and key.</summary>
            <param name="assignableFromServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="outermost">(optional)</param>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.GetScopeOrDefault(DryIoc.Request)">
            <summary>Creates or returns already created resolution root scope.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Created or existing scope.</returns>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.GetScopeExpression(DryIoc.Request)">
            <summary>Returns <see cref="M:DryIoc.IScopeAccess.GetMatchingResolutionScope(DryIoc.IScope,System.Type,System.Object,System.Boolean,System.Boolean)"/> method call expression.</summary>
            <param name="request">Request to get context information or for example store something in resolution state.</param>
            <returns>Method call expression returning existing or newly created resolution scope.</returns>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.GetScopedItemIdOrSelf(System.Int32,DryIoc.Request)">
            <summary>Just returns back passed id without changes.</summary>
            <param name="factoryID">Id to return back.</param> <param name="request">Ignored.</param>
            <returns><paramref name="factoryID"/></returns>
        </member>
        <member name="M:DryIoc.ResolutionScopeReuse.ToString">
            <summary>Pretty prints reuse name and lifespan</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.Reuse">
            <summary>Specifies pre-defined reuse behaviors supported by container: 
            used when registering services into container with <see cref="T:DryIoc.Registrator"/> methods.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Transient">
            <summary>Synonym for absence of reuse.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Singleton">
            <summary>Specifies to store single service instance per <see cref="T:DryIoc.Container"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InResolutionScope">
            <summary>Specifies to store single service instance per resolution root created by <see cref="T:DryIoc.Resolver"/> methods.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InCurrentScope">
            <summary>Specifies to store single service instance per current/open scope created with <see cref="M:DryIoc.Container.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/>.</summary>
        </member>
        <member name="M:DryIoc.Reuse.InCurrentNamedScope(System.Object)">
            <summary>Returns current scope reuse with specific name to match with scope.
            If name is not specified then function returns <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</summary>
            <param name="name">(optional) Name to match with scope.</param>
            <returns>Created current scope reuse.</returns>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf(System.Type,System.Object,System.Boolean)">
            <summary>Creates reuse to search for <paramref name="assignableFromServiceType"/> and <paramref name="serviceKey"/>
            in existing resolution scope hierarchy. If parameters are not specified or null, then <see cref="F:DryIoc.Reuse.InResolutionScope"/> will be returned.</summary>
            <param name="assignableFromServiceType">(optional) To search for scope with service type assignable to type specified in parameter.</param>
            <param name="serviceKey">(optional) Search for specified key.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <returns>New reuse with specified parameters or <see cref="F:DryIoc.Reuse.InResolutionScope"/> if nothing specified.</returns>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf``1(System.Object,System.Boolean)">
            <summary>Creates reuse to search for <typeparamref name="TAssignableFromServiceType"/> and <paramref name="serviceKey"/>
            in existing resolution scope hierarchy.</summary>
            <typeparam name="TAssignableFromServiceType">To search for scope with service type assignable to type specified in parameter.</typeparam>
            <param name="serviceKey">(optional) Search for specified key.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <returns>New reuse with specified parameters.</returns>
        </member>
        <member name="F:DryIoc.Reuse.InThread">
            <summary>Ensuring single service instance per Thread.</summary>
        </member>
        <member name="F:DryIoc.Reuse.WebRequestScopeName">
            <summary>Special name that by convention recognized by <see cref="F:DryIoc.Reuse.InWebRequest"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InWebRequest">
            <summary>Web request is just convention for reuse in <see cref="M:DryIoc.Reuse.InCurrentNamedScope(System.Object)"/> with special name <see cref="F:DryIoc.Reuse.WebRequestScopeName"/>.</summary>
        </member>
        <member name="T:DryIoc.IfUnresolved">
            <summary>Specifies what to return when <see cref="T:DryIoc.IResolver"/> unable to resolve service.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.Throw">
            <summary>Specifies to throw exception if no service found.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.ReturnDefault">
            <summary>Specifies to return default value instead of throwing error.</summary>
        </member>
        <member name="T:DryIoc.RequestInfo">
            <summary>Dependency request path information.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.Empty">
            <summary>Represents empty info (indicated by null <see cref="P:DryIoc.RequestInfo.ServiceType"/>).</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.ServiceInfo">
            <summary>Wraps the resolved service lookup details.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.IsEmpty">
            <summary>Returns true for an empty request.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.IsResolutionRoot">
            <summary>Returns true if request is the first in a chain.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.ParentOrWrapper">
            <summary>Parent request or null for root resolution request.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.Parent">
            <summary>Returns service parent skipping wrapper if any. To get immediate parent us <see cref="F:DryIoc.RequestInfo.ParentOrWrapper"/>.</summary>
        </member>
        <member name="M:DryIoc.RequestInfo.FirstOrEmpty(System.Func{DryIoc.RequestInfo,System.Boolean})">
            <summary>Gets first request info starting with itself which satisfies the condition, or empty otherwise.</summary>
            <param name="condition">Condition to stop on. Should not be null.</param>
            <returns>Request info of found parent.</returns>
        </member>
        <member name="P:DryIoc.RequestInfo.ServiceType">
            <summary>Requested service type.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.RequiredServiceType">
            <summary>Required service type if specified.</summary>
        </member>
        <member name="M:DryIoc.RequestInfo.GetActualServiceType">
            <summary>Returns <see cref="P:DryIoc.RequestInfo.RequiredServiceType"/> if it is specified and assignable to <see cref="P:DryIoc.RequestInfo.ServiceType"/>,
            otherwise returns <see cref="P:DryIoc.RequestInfo.ServiceType"/>.</summary>
            <returns>The type to be used for lookup in registry.</returns>
        </member>
        <member name="P:DryIoc.RequestInfo.IfUnresolved">
            <summary>Policy to deal with unresolved request.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.ServiceKey">
            <summary>Optional service key to identify service of the same type.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.FactoryID">
            <summary>Resolved factory ID, used to identify applied decorator.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.FactoryType">
            <summary>Type of factory: Service, Wrapper, or Decorator.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.ImplementationType">
            <summary>Service implementation type if known.</summary>
        </member>
        <member name="F:DryIoc.RequestInfo.Reuse">
            <summary>Service reuse.</summary>
        </member>
        <member name="P:DryIoc.RequestInfo.ReuseLifespan">
            <summary>Relative number representing reuse lifespan.</summary>
        </member>
        <member name="M:DryIoc.RequestInfo.Push(System.Type,System.Int32,System.Type,DryIoc.IReuse)">
            <summary>Simplified version of Push with most common properties.</summary>
            <param name="serviceType"></param> <param name="factoryID"></param> <param name="implementationType"></param>
            <param name="reuse"></param> <returns>Created info chain to current (parent) info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Push(System.Type,System.Type,System.Object,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
            <param name="serviceType"></param> <param name="requiredServiceType"></param>
            <param name="serviceKey"></param> <param name="factoryType"></param> <param name="factoryID"></param>
            <param name="implementationType"></param> <param name="reuse"></param>
            <returns>Created info chain to current (parent) info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Push(System.Type,System.Type,System.Object,DryIoc.IfUnresolved,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
            <param name="serviceType"></param> <param name="requiredServiceType"></param>
            <param name="serviceKey"></param> <param name="ifUnresolved"></param>
            <param name="factoryType"></param> <param name="factoryID"></param>
            <param name="implementationType"></param> <param name="reuse"></param>
            <returns>Created info chain to current (parent) info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Push(DryIoc.IServiceInfo,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
            <param name="serviceInfo"></param>
            <param name="factoryType">(optional)</param> <param name="factoryID">(optional)</param>
            <param name="implementationType">(optional)</param> <param name="reuse">(optional)</param>
            <returns>Created info chain to current (parent) info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.With(System.Func{DryIoc.IServiceInfo,DryIoc.IServiceInfo})">
            <summary>Produces new request info with specified service info.</summary>
            <param name="getServiceInfo">Gets new service info from the old one.</param> <returns>New request info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.With(System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse)">
            <summary>Produces new info adding the implementation (factory) details to the current info.</summary>
            <param name="factoryType"></param> <param name="factoryID"></param>
            <param name="implementationType"></param> <param name="reuse"></param>
            <returns>New request info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Enumerate">
            <summary>Returns all request until the root - parent is null.</summary>
            <returns>Requests from the last to first.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.PrintCurrent(System.Text.StringBuilder)">
            <summary>Prints request without parents.</summary>
            <param name="s">Where to print.</param><returns><paramref name="s"/> with appended info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Print(System.Text.StringBuilder)">
            <summary>Prints request with all its parents.</summary>
            <param name="s">Where to print.</param><returns><paramref name="s"/> with appended info.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.ToString">
            <summary>Prints request with all its parents to string.</summary> <returns>The string.</returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Equals(System.Object)">
            <summary>Returns true if request info and passed object are equal, and their parents recursively are equal.</summary>
            <param name="obj"></param> <returns></returns>
        </member>
        <member name="M:DryIoc.RequestInfo.Equals(DryIoc.RequestInfo)">
            <summary>Returns true if request info and passed info are equal, and their parents recursively are equal.</summary>
            <param name="other"></param> <returns></returns>
        </member>
        <member name="M:DryIoc.RequestInfo.EqualsWithoutParent(DryIoc.RequestInfo)">
            <summary>Compares info's regarding properties but not their parents.</summary>
            <param name="other">Info to compare for equality.</param> <returns></returns>
        </member>
        <member name="M:DryIoc.RequestInfo.GetHashCode">
            <summary>Returns hash code combined from info fields plus its parent.</summary>
            <returns>Combined hash code.</returns>
        </member>
        <member name="T:DryIoc.IResolver">
            <summary>Declares minimal API for service resolution.
            The user friendly convenient methods are implemented as extension methods in <see cref="T:DryIoc.Resolver"/> class.</summary>
            <remarks>Resolve default and keyed is separated because of micro optimization for faster resolution.</remarks>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,System.Boolean)">
            <summary>Resolves default (non-keyed) service from container and returns created service object.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="ifUnresolvedReturnDefault">Says what to do if service is unresolved.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolvedReturnDefault"/> provided.</returns>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,System.Object,System.Boolean,System.Type,DryIoc.RequestInfo,DryIoc.IScope)">
            <summary>Resolves service from container and returns created service object.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="serviceKey">Optional service key used for registering service.</param>
            <param name="ifUnresolvedReturnDefault">Says what to do if service is unresolved.</param>
            <param name="requiredServiceType">Actual registered service type to use instead of <paramref name="serviceType"/>, 
                or wrapped type for generic wrappers.  The type should be assignable to return <paramref name="serviceType"/>.</param>
            <param name="preResolveParent">Dependency resolution path info.</param>
            <param name="scope">Propagated resolution scope.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolvedReturnDefault"/> provided.</returns>
            <remarks>
            This method covers all possible resolution input parameters comparing to <see cref="M:DryIoc.IResolver.Resolve(System.Type,System.Boolean)"/>, and
            by specifying the same parameters as for <see cref="M:DryIoc.IResolver.Resolve(System.Type,System.Boolean)"/> should return the same result.
            </remarks>
        </member>
        <member name="M:DryIoc.IResolver.ResolveMany(System.Type,System.Object,System.Type,System.Object,System.Type,DryIoc.RequestInfo,DryIoc.IScope)">
            <summary>Resolves all services registered for specified <paramref name="serviceType"/>, or if not found returns
            empty enumerable. If <paramref name="serviceType"/> specified then returns only (single) service registered with
            this type. Excludes for result composite parent identified by <paramref name="compositeParentKey"/>.</summary>
            <param name="serviceType">Return type of an service item.</param>
            <param name="serviceKey">(optional) Resolve only single service registered with the key.</param>
            <param name="requiredServiceType">(optional) Actual registered service to search for.</param>
            <param name="compositeParentKey">OBSOLETE: Now I can use <paramref name="preResolveParent"/> to identify composite parent.</param>
            <param name="compositeParentRequiredType">OBSOLETE: Now I can use <paramref name="preResolveParent"/> to identify composite parent.</param>
            <param name="preResolveParent">Dependency resolution path info.</param>
            <param name="scope">propagated resolution scope, may be null.</param>
            <returns>Enumerable of found services or empty. Does Not throw if no service found.</returns>
        </member>
        <member name="T:DryIoc.IfAlreadyRegistered">
            <summary>Specifies options to handle situation when registered service is already present in the registry.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed">
            <summary>Appends new default registration or throws registration with the same key.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Throw">
            <summary>Throws if default or registration with the same key is already exist.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Keep">
            <summary>Keeps old default or keyed registration ignoring new registration: ensures Register-Once semantics.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Replace">
            <summary>Replaces old registration with new one.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNewImplementation">
            <summary>Adds new implementation or null (Made.Of), 
            skips registration if the implementation is already registered.</summary>
        </member>
        <member name="T:DryIoc.ServiceRegistrationInfo">
            <summary>Define registered service structure.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.ServiceType">
            <summary>Required service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.OptionalServiceKey">
            <summary>Is null single default service, or actual service key, or <see cref="T:DryIoc.DefaultKey"/> for multiple default services.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.Factory">
            <summary>Registered factory.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.FactoryRegistrationOrder">
            <summary>Provides registration order across all factory registrations in container.</summary>
            <remarks>May be repeated for factory registered with multiple services.</remarks>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.#ctor(DryIoc.Factory,System.Type,System.Object)">
            <summary>Creates info. Registration order is figured out automatically based on Factory.</summary>
            <param name="factory"></param> <param name="serviceType"></param> <param name="optionalServiceKey"></param>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToString">
            <summary>Pretty-prints info to string.</summary> <returns>The string.</returns>
        </member>
        <member name="T:DryIoc.IRegistrator">
            <summary>Defines operations that for changing registry, and checking if something exist in registry.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.</summary>
            <returns>Existing registrations.</returns>
            <remarks>Decorator and Wrapper types are not included.</remarks>
        </member>
        <member name="M:DryIoc.IRegistrator.Register(DryIoc.Factory,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean)">
            <summary>Registers factory in registry with specified service type and key for lookup.
            Returns true if factory was added to registry, false otherwise. False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> 
            setting and already existing factory</summary>
            <param name="factory">To register.</param>
            <param name="serviceType">Service type as unique key in registry for lookup.</param>
            <param name="serviceKey">Service key as complementary lookup for the same service type.</param>
            <param name="ifAlreadyRegistered">Policy how to deal with already registered factory with same service type and key.</param>
            <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise. 
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.IRegistrator.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if expected factory is registered with specified service key and type.</summary>
            <param name="serviceType">Type to lookup.</param>
            <param name="serviceKey">Key to lookup for the same type.</param>
            <param name="factoryType">Expected factory type.</param>
            <param name="condition">Expected factory condition.</param>
            <returns>True if expected factory found in registry.</returns>
        </member>
        <member name="M:DryIoc.IRegistrator.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes factory with specified service type and key from registry.</summary>
            <param name="serviceType">Type to lookup.</param>
            <param name="serviceKey">Key to lookup for the same type.</param>
            <param name="factoryType">Expected factory type.</param>
            <param name="condition">Expected factory condition.</param>
        </member>
        <member name="T:DryIoc.IScopeAccess">
            <summary>Provides access to scopes.</summary>
        </member>
        <member name="P:DryIoc.IScopeAccess.SingletonScope">
            <summary>Scope containing container singletons.</summary>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetCurrentScope">
            <summary>Current scope.</summary>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetCurrentNamedScope(System.Object,System.Boolean)">
            <summary>Gets current scope matching the <paramref name="name"/>. 
            If name is null then current scope is returned, or if there is no current scope then exception thrown.</summary>
            <param name="name">May be null</param> <returns>Found scope or throws exception.</returns>
            <param name="throwIfNotFound">Says to throw if no scope found.</param>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetOrCreateResolutionScope(DryIoc.IScope@,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param> 
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetOrNewResolutionScope(DryIoc.IScope,System.Type,System.Object)">
            <summary>Check if scope is not null, then just returns it, otherwise will create and return it.</summary>
            <param name="scope">May be null scope.</param>
            <param name="serviceType">Marking scope with resolved service type.</param> 
            <param name="serviceKey">Marking scope with resolved service key.</param>
            <returns>Input <paramref name="scope"/> ensuring it is not null.</returns>
        </member>
        <member name="M:DryIoc.IScopeAccess.GetMatchingResolutionScope(DryIoc.IScope,System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>If both <paramref name="assignableFromServiceType"/> and <paramref name="serviceKey"/> are null, 
            then returns input <paramref name="scope"/>.
            Otherwise searches scope hierarchy to find first scope with: Type assignable <paramref name="assignableFromServiceType"/> and 
            Key equal to <paramref name="serviceKey"/>.</summary>
            <param name="scope">Scope to start matching with Type and Key specified.</param>
            <param name="assignableFromServiceType">Type to match.</param> <param name="serviceKey">Key to match.</param>
            <param name="outermost">If true - commands to look for outermost match instead of nearest.</param>
            <param name="throwIfNotFound">Says to throw if no scope found.</param>
        </member>
        <member name="T:DryIoc.IContainer">
            <summary>Exposes operations required for internal registry access. 
            That's why most of them are implemented explicitly by <see cref="T:DryIoc.Container"/>.</summary>
        </member>
        <member name="P:DryIoc.IContainer.ContainerWeakRef">
            <summary>Self weak reference, with readable message when container is GCed/Disposed.</summary>
        </member>
        <member name="P:DryIoc.IContainer.Rules">
            <summary>Rules for defining resolution/registration behavior throughout container.</summary>
        </member>
        <member name="P:DryIoc.IContainer.EmptyRequest">
            <summary>Empty request bound to container. All other requests are created by pushing to empty request.</summary>
        </member>
        <member name="P:DryIoc.IContainer.ResolutionStateCache">
            <summary>State item objects which may include: singleton instances for fast access, reuses, reuse wrappers, factory delegates, etc.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Copies all of container state except Cache and specifies new rules.</summary>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param> 
            <param name="scopeContext">(optional) New scope context, if not specified then uses context from current container.</param>
            <returns>New container.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional)Controls what to do with registrations: ignore or throw exception.
            Throws exception by default.</param>
            <returns>New container preserving all current container state but disallowing registrations.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithoutCache">
            <summary>Returns new container with all expression, delegate, items cache removed/reset.
            It will preserve resolved services in Singleton/Current scope.</summary>
            <returns>New container with empty cache.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithoutSingletonsAndCache">
            <summary>Creates new container with whole state shared with original except singletons.</summary>
            <returns>New container with empty Singleton Scope.</returns>
        </member>
        <member name="M:DryIoc.IContainer.WithRegistrationsCopy(System.Boolean)">
            <summary>Shares all parts with original container But copies registration, so the new registration
            won't be visible in original. Registrations include decorators and wrappers as well.</summary>
            <param name="preserveCache">(optional) If set preserves cache if you know what to do.</param>
            <returns>New container with copy of all registrations.</returns>
        </member>
        <member name="P:DryIoc.IContainer.ScopeContext">
            <summary>Returns scope context associated with container.</summary>
        </member>
        <member name="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})">
            <summary>Creates new container with new opened scope, with shared registrations, singletons and resolutions cache.
            If container uses ambient scope context, then this method sets new opened scope as current scope in the context.
            In case of previous open scope, new open scope references old one as a parent.
            </summary>
            <param name="name">(optional) Name for opened scope to allow reuse to identify the scope.</param>
            <param name="configure">(optional) Configure rules, if not specified then uses Rules from current container.</param> 
            <returns>New container with different current scope.</returns>
            <example><code lang="cs"><![CDATA[
            using (var scoped = container.OpenScope())
            {
                var handler = scoped.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
        </member>
        <member name="M:DryIoc.IContainer.CreateFacade">
            <summary>Creates container (facade) that fallbacks to this container for unresolved services.
            Facade shares rules with this container, everything else is its own. 
            It could be used for instance to create Test facade over original container with replacing some services with test ones.</summary>
            <remarks>Singletons from container are not reused by facade, to achieve that rather use <see cref="M:DryIoc.IContainer.OpenScope(System.Object,System.Func{DryIoc.Rules,DryIoc.Rules})"/> with <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</remarks>
            <returns>New facade container.</returns>
        </member>
        <member name="M:DryIoc.IContainer.ResolveFactory(DryIoc.Request)">
            <summary>Searches for requested factory in registry, and then using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/>.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory, otherwise null if <see cref="P:DryIoc.Request.IfUnresolved"/> is set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetServiceFactoryOrDefault(DryIoc.Request)">
            <summary>Searches for registered service factory and returns it, or null if not found.</summary>
            <param name="request">Factory request.</param>
            <returns>Found registered factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetAllServiceFactories(System.Type,System.Boolean)">
            <summary>Finds all registered default and keyed service factories and returns them.
            It skips decorators and wrappers.</summary>
            <param name="serviceType">Service type to look for, may be open-generic type too.</param>
            <param name="bothClosedAndOpenGenerics">(optional) For generic serviceType instructs to look for
            both closed and open-generic registrations.</param>
            <returns>Enumerable of found pairs.</returns>
            <remarks>Returned Key item should not be null - it should be <see cref="F:DryIoc.DefaultKey.Value"/>.</remarks>
        </member>
        <member name="M:DryIoc.IContainer.GetWrapperFactoryOrDefault(System.Type)">
            <summary>Searches for registered wrapper factory and returns it, or null if not found.</summary>
            <param name="serviceType">Service type to look for.</param> <returns>Found wrapper factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorFactoriesOrDefault(System.Type)">
            <summary>Returns all decorators registered for the service type.</summary> <returns>Decorator factories.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorExpressionOrDefault(DryIoc.Request)">
            <summary>Creates decorator expression: it could be either Func{TService,TService}, 
            or service expression for replacing decorators.</summary>
            <param name="request">Decorated service request.</param>
            <returns>Decorator expression.</returns>
        </member>
        <member name="M:DryIoc.IContainer.InjectPropertiesAndFields(System.Object,DryIoc.PropertiesAndFieldsSelector)">
            <summary>For given instance resolves and sets properties and fields.</summary>
            <param name="instance">Service instance with properties to resolve and initialize.</param>
            <param name="propertiesAndFields">(optional) Function to select properties and fields, overrides all other rules if specified.</param>
            <returns>Instance with assigned properties and fields.</returns>
            <remarks>Different Rules could be combined together using <see cref="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/> method.</remarks>     
        </member>
        <member name="M:DryIoc.IContainer.GetWrappedType(System.Type,System.Type)">
            <summary>If <paramref name="serviceType"/> is generic type then this method checks if the type registered as generic wrapper,
            and recursively unwraps and returns its type argument. This type argument is the actual service type we want to find.
            Otherwise, method returns the input <paramref name="serviceType"/>.</summary>
            <param name="serviceType">Type to unwrap. Method will return early if type is not generic.</param>
            <param name="requiredServiceType">Required service type or null if don't care.</param>
            <returns>Unwrapped service type in case it corresponds to registered generic wrapper, or input type in all other cases.</returns>
        </member>
        <member name="M:DryIoc.IContainer.CacheFactoryExpression(System.Int32,System.Linq.Expressions.Expression)">
            <summary>Adds factory expression to cache identified by factory ID (<see cref="P:DryIoc.Factory.FactoryID"/>).</summary>
            <param name="factoryID">Key in cache.</param>
            <param name="factoryExpression">Value to cache.</param>
        </member>
        <member name="M:DryIoc.IContainer.GetCachedFactoryExpressionOrDefault(System.Int32)">
            <summary>Searches and returns cached factory expression, or null if not found.</summary>
            <param name="factoryID">Factory ID to lookup by.</param> <returns>Found expression or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetOrAddStateItemExpression(System.Object,System.Type,System.Boolean)">
            <summary>If possible wraps added item in <see cref="T:System.Linq.Expressions.ConstantExpression"/> (possible for primitive type, Type, strings), 
            otherwise invokes <see cref="M:DryIoc.Container.GetOrAddStateItem(System.Object)"/> and wraps access to added item (by returned index) into expression: state => state.Get(index).</summary>
            <param name="item">Item to wrap or to add.</param> <param name="itemType">(optional) Specific type of item, otherwise item <see cref="M:System.Object.GetType"/>.</param>
            <param name="throwIfStateRequired">(optional) Enable filtering of stateful items.</param>
            <returns>Returns constant or state access expression for added items.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetOrAddStateItem(System.Object)">
            <summary>Adds item if it is not already added to state, returns added or existing item index.</summary>
            <param name="item">Item to find in existing items with <see cref="M:System.Object.Equals(System.Object,System.Object)"/> or add if not found.</param>
            <returns>Index of found or added item.</returns>
        </member>
        <member name="T:DryIoc.LazyEnumerable`1">
            <summary>Resolves all registered services of <typeparamref name="TService"/> type on demand, 
            when enumerator <see cref="M:System.Collections.IEnumerator.MoveNext"/> called. If service type is not found, empty returned.</summary>
            <typeparam name="TService">Service type to resolve.</typeparam>
        </member>
        <member name="F:DryIoc.LazyEnumerable`1.Items">
            <summary>Exposes internal items enumerable.</summary>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Wraps lazy resolved items.</summary> <param name="items">Lazy resolved items.</param>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.GetEnumerator">
            <summary>Return items enumerator.</summary> <returns>items enumerator.</returns>
        </member>
        <member name="T:DryIoc.Meta`2">
            <summary>Wrapper type to box service with associated arbitrary metadata object.</summary>
            <typeparam name="T">Service type.</typeparam>
            <typeparam name="TMetadata">Arbitrary metadata object type.</typeparam>
        </member>
        <member name="F:DryIoc.Meta`2.Value">
            <summary>Value or object with associated metadata.</summary>
        </member>
        <member name="F:DryIoc.Meta`2.Metadata">
            <summary>Associated metadata object. Could be anything.</summary>
        </member>
        <member name="M:DryIoc.Meta`2.#ctor(`0,`1)">
            <summary>Boxes value and its associated metadata together.</summary>
            <param name="value">value</param> <param name="metadata">any metadata object</param>
        </member>
        <member name="T:DryIoc.ContainerException">
            <summary>Exception that container throws in case of error. Dedicated exception type simplifies
            filtering or catching container relevant exceptions from client code.</summary>
        </member>
        <member name="F:DryIoc.ContainerException.Error">
            <summary>Error code of exception, possible values are listed in <see cref="F:DryIoc.ContainerException.Error"/> class.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.Of(DryIoc.ErrorCheck,System.Int32,System.Object,System.Object,System.Object,System.Object,System.Exception)">
            <summary>Creates exception by wrapping <paramref name="errorCode"/> and its message,
            optionally with <paramref name="innerException"/> exception.</summary>
            <param name="errorCheck">Type of check</param>
            <param name="errorCode">Error code, check <see cref="F:DryIoc.ContainerException.Error"/> for possible values.</param>
            <param name="arg0">(optional) Arguments for formatted message.</param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <param name="innerException">(optional) Inner exception.</param>
            <returns>Created exception.</returns>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String)">
            <summary>Creates exception with message describing cause and context of error.</summary>
            <param name="error">Error code.</param> <param name="message">Error message.</param>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>Creates exception with message describing cause and context of error,
            and leading/system exception causing it.</summary>
            <param name="error">Error code.</param> <param name="message">Error message.</param>
            <param name="innerException">Underlying system/leading exception.</param>
        </member>
        <member name="M:DryIoc.ContainerException.Print(System.Object)">
            <summary>Prints argument for formatted message.</summary> <param name="arg">To print.</param> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.Error">
            <summary>Defines error codes and error messages for all DryIoc exceptions (DryIoc extensions may define their own.)</summary>
        </member>
        <member name="F:DryIoc.Error.FirstErrorCode">
            <summary>First error code to identify error range for other possible error code definitions.</summary>
        </member>
        <member name="F:DryIoc.Error.Messages">
            <summary>List of error messages indexed with code.</summary>
        </member>
        <member name="M:DryIoc.Error.Of(System.String)">
            <summary>Stores new error message and returns error code for it.</summary>
            <param name="message">Error message to store.</param> <returns>Error code for message.</returns>
        </member>
        <member name="M:DryIoc.Error.NameOf(System.Int32)">
            <summary>Returns the name for the provided error code.</summary>
            <param name="error">error code.</param> <returns>name of error, unique in scope of this <see cref="T:DryIoc.Error"/> class.</returns>
        </member>
        <member name="T:DryIoc.ErrorCheck">
            <summary>Checked error condition, possible error sources.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.Unspecified">
            <summary>Unspecified, just throw.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.InvalidCondition">
            <summary>Predicate evaluated to false.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNull">
            <summary>Checked object is null.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNotOfType">
            <summary>Checked object is of unexpected type.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.TypeIsNotOfType">
            <summary>Checked type is not assignable to expected type</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.OperationThrows">
            <summary>Invoked operation throw, it is source of inner exception.</summary>
        </member>
        <member name="T:DryIoc.Throw">
            <summary>Enables more clean error message formatting and a bit of code contracts.</summary>
        </member>
        <member name="T:DryIoc.Throw.GetMatchedExceptionHandler">
            <summary>Declares mapping between <see cref="T:DryIoc.ErrorCheck"/> type and <paramref name="error"/> code to specific <see cref="T:System.Exception"/>.</summary>
            <returns>Returns mapped exception.</returns>
        </member>
        <member name="F:DryIoc.Throw.GetMatchedException">
            <summary>Returns matched exception (to check type and error code). By default return <see cref="T:DryIoc.ContainerException"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.If(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception if throw condition is true.</summary>
            <param name="throwCondition">Condition to be evaluated, throws if result is true, otherwise - does nothing.</param>
            <param name="error">Error code to match to exception thrown.</param>
            <param name="arg0">Arguments to formatted message.</param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
        </member>
        <member name="M:DryIoc.Throw.ThrowIf``1(``0,System.Boolean,System.Int32,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception if throw condition is true. Otherwise return source <paramref name="arg0"/>.</summary>
            <typeparam name="T">Type of source <paramref name="arg0"/>.</typeparam>
            <param name="arg0">In case of exception <paramref name="arg0"/> will be used as first argument in formatted message.</param>
            <param name="throwCondition">Condition to be evaluated, throws if result is true, otherwise - does nothing.</param>
            <param name="error">Error code to match to exception thrown.</param>
            <param name="arg1">Rest of arguments to formatted message.</param> <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if throw condition is false.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNull``1(``0,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg"/> is null, otherwise returns <paramref name="arg"/>.</summary>
            <param name="arg">Argument to check for null.</param>
            <param name="error">Error code.</param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <typeparam name="T">Type of argument to check and return.</typeparam>
            <returns><paramref name="arg"/> if it is not null.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotOf``1(``0,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg0"/> is not assignable to type specified by <paramref name="arg1"/>,
            otherwise just returns <paramref name="arg0"/>.</summary>
            <typeparam name="T">Type of argument to check and return if no error.</typeparam>
            <param name="arg0">Instance to check if it is assignable to type <paramref name="arg1"/>.</param>
            <param name="arg1">Type to check <paramref name="arg0"/> against.</param>
            <param name="error">Error code</param>
            <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if it assignable to <paramref name="arg1"/>.</returns>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotImplementedBy(System.Type,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws if <paramref name="arg0"/> is not assignable from <paramref name="arg1"/>.</summary>
            <param name="arg0"></param> <param name="arg1"></param> 
            <param name="error">Error code</param>
             <param name="arg2"></param> <param name="arg3"></param>
            <returns><paramref name="arg0"/> if no exception.</returns>
        </member>
        <member name="M:DryIoc.Throw.IfThrows``2(System.Func{``1},System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Invokes <paramref name="operation"/> and in case of <typeparamref name="TEx"/> re-throws it as inner-exception.</summary>
            <typeparam name="TEx">Exception to check and handle, and then wrap as inner-exception.</typeparam>
            <typeparam name="T">Result of <paramref name="operation"/>.</typeparam>
            <param name="operation">To invoke</param>
            <param name="throwCondition">Condition to be evaluated, throws if result is true, otherwise - does nothing.</param>
            <param name="error">Error code</param>
            <param name="arg0"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns>Result of <paramref name="operation"/> if no exception.</returns>
        </member>
        <member name="M:DryIoc.Throw.It(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Just throws the exception with the <paramref name="error"/> code.</summary>
            <param name="error">Error code.</param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
        </member>
        <member name="M:DryIoc.Throw.For``1(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws <paramref name="error"/> instead of returning value of <typeparamref name="T"/>. 
            Supposed to be used in expression that require some return value.</summary>
            <typeparam name="T"></typeparam> <param name="error"></param>
            <param name="arg0"></param> <param name="arg1"></param> <param name="arg2"></param> <param name="arg3"></param>
            <returns>Does not return, throws instead.</returns>
        </member>
        <member name="T:DryIoc.ThrowInGeneratedCode">
            <summary>Called from generated code.</summary>
        </member>
        <member name="M:DryIoc.ThrowInGeneratedCode.ThrowNewErrorIfNull(System.Object,System.String)">
            <summary>Throws if object is null.</summary>
            <param name="obj">object to check.</param><param name="message">Error message.</param>
            <returns>object if not null.</returns>
        </member>
        <member name="T:DryIoc.ReflectionTools">
            <summary>Contains helper methods to work with Type: for instance to find Type implemented base types and interfaces, etc.</summary>
        </member>
        <member name="T:DryIoc.ReflectionTools.AsImplementedType">
            <summary>Flags for <see cref="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)"/> method.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.None">
            <summary>Include nor object not source type.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.SourceType">
            <summary>Include source type to list of implemented types.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.ObjectType">
            <summary>Include <see cref="T:System.Object"/> type to list of implemented types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)">
            <summary>Returns all interfaces and all base types (in that order) implemented by <paramref name="sourceType"/>.
            Specify <paramref name="asImplementedType"/> to include <paramref name="sourceType"/> itself as first item and 
            <see cref="T:System.Object"/> type as the last item.</summary>
            <param name="sourceType">Source type for discovery.</param>
            <param name="asImplementedType">Additional types to include into result collection.</param>
            <returns>Array of found types, empty if nothing found.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedInterfaces(System.Type)">
            <summary>Gets a collection of the interfaces implemented by the current type and its base types.</summary>
            <param name="type">Source type</param>
            <returns>Collection of interface types.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAllMembers(System.Type)">
            <summary>Gets all declared and base members.</summary>
            <param name="type">Type to get members from.</param> <returns>All members.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.ContainsAllGenericTypeParameters(System.Type,System.Type[])">
            <summary>Returns true if <paramref name="openGenericType"/> contains all generic parameters 
            from <paramref name="genericParameters"/>.</summary>
            <param name="openGenericType">Expected to be open-generic type.</param>
            <param name="genericParameters">Generic parameters.</param>
            <returns>Returns true if contains and false otherwise.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsCompilerGenerated(System.Type)">
            <summary>Returns true if class is compiler generated. Checking for CompilerGeneratedAttribute
            is not enough, because this attribute is not applied for classes generated from "async/await".</summary>
            <param name="type">Type to check.</param> <returns>Returns true if type is compiler generated.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGeneric(System.Type)">
            <summary>Returns true if type is generic.</summary><param name="type">Type to check.</param> <returns>True if type generic.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGenericDefinition(System.Type)">
            <summary>Returns true if type is generic type definition (open type).</summary><param name="type">Type to check.</param>
            <returns>True if type is open type: generic type definition.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosedGeneric(System.Type)">
            <summary>Returns true if type is closed generic: does not have open generic parameters, only closed/concrete ones.</summary>
            <param name="type">Type to check</param> <returns>True if closed generic.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsOpenGeneric(System.Type)">
            <summary>Returns true if type if open generic: contains at list one open generic parameter. Could be
            generic type definition as well.</summary>
            <param name="type">Type to check.</param> <returns>True if open generic.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericDefinitionOrNull(System.Type)">
            <summary>Returns generic type definition if type is generic and null otherwise.</summary>
            <param name="type">Source type, could be null.</param> <returns>Generic type definition.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamsAndArgs(System.Type)">
            <summary>Returns generic type parameters and arguments in order they specified. If type is not generic, returns empty array.</summary>
            <param name="type">Source type.</param> <returns>Array of generic type arguments (closed/concrete types) and parameters (open).</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamConstraints(System.Type)">
            <summary>Returns array of interface and base class constraints for provider generic parameter type.</summary>
            <param name="type">Generic parameter type.</param>
            <returns>Array of interface and base class constraints.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetArrayElementTypeOrNull(System.Type)">
            <summary>If type is array returns is element type, otherwise returns null.</summary>
            <param name="type">Source type.</param> <returns>Array element type or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetBaseType(System.Type)">
            <summary>Return base type or null, if not exist (the case for only for object type).</summary> 
            <param name="type">Source type.</param> <returns>Base type or null for object.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPublicOrNestedPublic(System.Type)">
            <summary>Checks if type is public or nested public in public type.</summary>
            <param name="type">Type to check.</param> <returns>Return true if check succeeded.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsValueType(System.Type)">
            <summary>Returns true if type is value type.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAbstract(System.Type)">
            <summary>Returns true if type if abstract or interface.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Type)">
            <summary>Returns true if type is static.</summary>
            <param name="type">Type</param> <returns>True is static.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsEnum(System.Type)">
            <summary>Returns true if type is enum type.</summary>
            <param name="type">Type to check.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableTo(System.Type,System.Type)">
            <summary>Returns true if instance of type is assignable to instance of <paramref name="other"/> type.</summary>
            <param name="type">Type to check, could be null.</param> 
            <param name="other">Other type to check, could be null.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsTypeOf(System.Type,System.Object)">
            <summary>Returns true if type of <paramref name="obj"/> is assignable to source <paramref name="type"/>.</summary>
            <param name="type">Is type of object.</param> <param name="obj">Object to check.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPrimitive(System.Type,System.Boolean)">
            <summary>Returns true if provided type IsPitmitive in .Net terms, or enum, or string
            , or array of primitives if <paramref name="orArrayOfPrimitives"/> is true.</summary>
            <param name="type">Type to check.</param> 
            <param name="orArrayOfPrimitives">Says to return true for array or primitives recursively.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Type,System.Type,System.Boolean)">
            <summary>Returns all attributes defined on <paramref name="type"/>.</summary>
            <param name="type">Type to get attributes for.</param>
            <param name="attributeType">(optional) Check only for that attribute type, otherwise for any attribute.</param>
            <param name="inherit">(optional) Additionally check for attributes inherited from base type.</param>
            <returns>Sequence of found attributes or empty.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetDeclaredAndBase``1(System.Type,System.Func{System.Reflection.TypeInfo,System.Collections.Generic.IEnumerable{``0}})">
            <summary>Recursive method to enumerate all input type and its base types for specific details.
            Details are returned by <paramref name="getDeclared"/> delegate.</summary>
            <typeparam name="T">Details type: properties, fields, methods, etc.</typeparam>
            <param name="type">Input type.</param> <param name="getDeclared">Get declared type details.</param>
            <returns>Enumerated details info objects.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetPublicInstanceConstructors(System.Type)">
            <summary>Returns all public instance constructors for the type</summary> 
            <param name="type"></param> <returns></returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAllConstructors(System.Type,System.Boolean,System.Boolean)">
            <summary>Enumerates all constructors from input type.</summary>
            <param name="type">Input type.</param>
            <param name="includeNonPublic">(optional) If set include non-public constructors into result.</param>
            <param name="includeStatic">(optional) Turned off by default.</param>
            <returns>Enumerated constructors.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConstructorOrNull(System.Type,System.Boolean,System.Type[])">
            <summary>Searches and returns constructor by its signature.</summary>
            <param name="type">Input type.</param>
            <param name="includeNonPublic">(optional) If set include non-public constructors into result.</param>
            <param name="args">Signature - constructor argument types.</param>
            <returns>Found constructor or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleConstructorOrNull(System.Type,System.Boolean)">
            <summary>Returns single constructor, otherwise if no or more than one: returns false.</summary>
            <param name="type">Type to inspect.</param>
            <param name="includeNonPublic">(optional) If set includes non-public constructors.</param>
            <returns>Single constructor or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleMethodOrNull(System.Type,System.String,System.Boolean)">
            <summary>Returns single declared (not inherited) method by name, or null if not found.</summary>
            <param name="type">Input type</param> <param name="name">Method name to look for.</param>
            <param name="includeNonPublic">(optional) If set includes non public methods into search.</param>
            <returns>Found method or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetMethodOrNull(System.Type,System.String,System.Type[])">
            <summary>Returns declared (not inherited) method by name and argument types, or null if not found.</summary>
            <param name="type">Input type</param> <param name="name">Method name to look for.</param>
            <param name="args">Argument types</param> <returns>Found method or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetPropertyOrNull(System.Type,System.String)">
            <summary>Returns property by name, including inherited. Or null if not found.</summary>
            <param name="type">Input type.</param> <param name="name">Property name to look for.</param>
            <returns>Found property or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetFieldOrNull(System.Type,System.String)">
            <summary>Returns field by name, including inherited. Or null if not found.</summary>
            <param name="type">Input type.</param> <param name="name">Field name to look for.</param>
            <returns>Found field or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAssembly(System.Type)">
            <summary>Returns type assembly.</summary> <param name="type">Input type</param> <returns>Type assembly.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Reflection.MemberInfo)">
            <summary>Returns true if member is static, otherwise returns false.</summary>
            <param name="member">Member to check.</param> <returns>True if static.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetReturnTypeOrDefault(System.Reflection.MemberInfo)">
            <summary>Return either <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>, or <see cref="P:System.Reflection.FieldInfo.FieldType"/>, <see cref="P:System.Reflection.MethodInfo.ReturnType"/>.
            Otherwise returns null.</summary>
            <param name="member">Expecting member of type <see cref="T:System.Reflection.PropertyInfo"/> or <see cref="T:System.Reflection.FieldInfo"/> only.</param>
            <returns>Type of property of field.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsBackingField(System.Reflection.FieldInfo)">
            <summary>Returns true if field is backing field for property.</summary>
            <param name="field">Field to check.</param> <returns>Returns true if field is backing property.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsIndexer(System.Reflection.PropertyInfo)">
            <summary>Returns true if property is indexer: aka this[].</summary>
            <param name="property">Property to check</param><returns>True if indexer.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosureType(System.Type)">
            <summary>Returns true if type is generated type of hoisted closure.</summary>
            <param name="type">Source type.</param> <returns>Check result.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for the member/method.</summary>
            <param name="member">Member to check.</param> <param name="attributeType">(optional) Specific attribute type to return, any attribute otherwise.</param>
            <param name="inherit">Check for inherited member attributes.</param> <returns>Found attributes or empty.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.ParameterInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for parameter.</summary>
             <param name="parameter">Target parameter.</param> 
            <param name="attributeType">(optional) Specific attribute type to return, any attribute otherwise.</param>
            <param name="inherit">Check for inherited attributes.</param> <returns>Found attributes or empty.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetLoadedTypes(System.Reflection.Assembly)">
            <summary>Get types from assembly that are loaded successfully. 
            Hacks to <see cref="T:System.Reflection.ReflectionTypeLoadException"/> for loaded types.</summary>
            <param name="assembly">Assembly to get types from.</param>
            <returns>Array of loaded types.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetDefaultValueExpression(System.Type)">
            <summary>Creates default(T) expression for provided <paramref name="type"/>.</summary>
            <param name="type">Type to get default value of.</param>
            <returns>Default value expression.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.ToExpression``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>Utility to convert passed func/delegate to expression.</summary>
            <typeparam name="T">Type of expression result.</typeparam> <param name="func">Delegate to convert.</param>
            <returns>Delegate expression.</returns>
        </member>
        <member name="T:DryIoc.PrintTools">
            <summary>Provides pretty printing/debug view for number of types.</summary>
        </member>
        <member name="F:DryIoc.PrintTools.DefaultItemSeparator">
            <summary>Default separator used for printing enumerable.</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Object,System.String,System.String,System.Func{System.Type,System.String})">
            <summary>Prints input object by using corresponding Print methods for know types.</summary>
            <param name="s">Builder to append output to.</param>
            <param name="x">Object to print.</param>
            <param name="quote">(optional) Quote to use for quoting string object.</param>
            <param name="itemSeparator">(optional) Separator for enumerable.</param>
            <param name="getTypeName">(optional) Custom type printing policy.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.String,System.String)">
            <summary>Appends string to string builder quoting with <paramref name="quote"/> if provided.</summary>
            <param name="s">String builder to append string to.</param>
            <param name="str">String to print.</param>
            <param name="quote">(optional) Quote to add before and after string.</param>
            <returns>String builder with appended string.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Collections.IEnumerable,System.String,System.Action{System.Text.StringBuilder,System.Object})">
            <summary>Prints enumerable by using corresponding Print method for known item type.</summary>
            <param name="s">String builder to append output to.</param>
            <param name="items">Items to print.</param>
            <param name="separator">(optional) Custom separator if provided.</param>
            <param name="printItem">(optional) Custom item printer if provided.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="F:DryIoc.PrintTools.GetTypeNameDefault">
            <summary>Default delegate to print Type details: by default prints Type FullName and
            skips namespace if it start with "System."</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Type,System.Func{System.Type,System.String})">
            <summary>Appends type details to string builder.</summary>
            <param name="s">String builder to append output to.</param>
            <param name="type">Input type to print.</param>
            <param name="getTypeName">(optional) Delegate to provide custom type details.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="T:DryIoc.Portable">
            <summary>Ports some methods from .Net 4.0/4.5</summary>
        </member>
        <member name="F:DryIoc.Portable.GetAssemblyTypes">
            <summary>Portable version of Assembly.GetTypes or Assembly.DefinedTypes.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetGetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetGetMethod.</summary>
            <param name="p">Target property info</param>
            <param name="includeNonPublic">(optional) If set then consider non-public getter</param>
            <returns>Setter method info if it is defined for property.</returns>
        </member>
        <member name="M:DryIoc.Portable.GetSetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetSetMethod.</summary>
            <param name="p">Target property info</param>
            <param name="includeNonPublic">(optional) If set then consider non-public setter</param>
            <returns>Setter method info if it is defined for property.</returns>
        </member>
        <member name="M:DryIoc.Portable.GetCurrentManagedThreadID">
            <summary>Returns managed Thread ID either from Environment or Thread.CurrentThread whichever is available.</summary>
            <returns>Managed Thread ID.</returns>
        </member>
        <member name="T:DryIoc.Experimental.D">
            <summary>Succinct convention-based, LINQ like API to resolve resolution root at the end.</summary>
        </member>
        <member name="P:DryIoc.Experimental.D.I">
            <summary>Creates new default configured container</summary>
            <value>New configured container.</value>
        </member>
        <member name="M:DryIoc.Experimental.D.Get``1(DryIoc.IContainer,System.Reflection.Assembly[])">
            <summary>Auto-wired resolution of T from the container.</summary>
            <typeparam name="T">Type of service to resolve.</typeparam>
            <param name="container">(optional) Container </param>
            <param name="assemblies">(optional) Assemblies to look for service implementation and dependencies.</param>
            <returns>Resolved service or throws.</returns>
        </member>
        <member name="T:DryIoc.ArrayTools">
            <summary>Methods to work with immutable arrays, and general array sugar.</summary>
        </member>
        <member name="M:DryIoc.ArrayTools.IsNullOrEmpty``1(``0[])">
            <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.EmptyIfNull``1(``0[])">
            <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Source array.</param> <returns>Empty array or source.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.ToArrayOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns source enumerable if it is array, otherwise converts source to array.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Source enumerable.</param>
            <returns>Source enumerable or its array copy.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.Append``1(``0[],``0[])">
            <summary>Returns new array consisting from all items from source array then all items from added array.
            If source is null or empty, then added array will be returned.
            If added is null or empty, then source will be returned.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array with leading items.</param>
            <param name="added">Array with following items.</param>
            <returns>New array with items of source and added arrays.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.AppendOrUpdate``1(``0[],``0,System.Int32)">
            <summary>Returns new array with <paramref name="value"/> appended, 
            or <paramref name="value"/> at <paramref name="index"/>, if specified.
            If source array could be null or empty, then single value item array will be created despite any index.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array to append value to.</param>
            <param name="value">Value to append.</param>
            <param name="index">(optional) Index of value to update.</param>
            <returns>New array with appended or updated value.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.IndexOf``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
            then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="predicate">Delegate to evaluate on each array item until delegate returns true.</param>
            <returns>Index of item for which predicate returns true, or -1 otherwise.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.IndexOf``1(``0[],``0)">
            <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="value">Value to look up.</param>
            <returns>Index of item equal to value, or -1 item is not found.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.RemoveAt``1(``0[],System.Int32)">
            <summary>Produces new array without item at specified <paramref name="index"/>. 
            Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="index">Index if item to remove.</param>
            <returns>New array with removed item at index, or input source array if index is not in array.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.Remove``1(``0[],``0)">
            <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="value">Value to find and remove.</param>
            <returns>New array with value removed or original array if value is not found.</returns>
        </member>
        <member name="M:DryIoc.ArrayTools.Empty``1">
            <summary>Returns singleton empty array of provided type.</summary> 
            <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        </member>
        <member name="T:DryIoc.Ref`1">
            <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="M:DryIoc.Ref.Swap``1(``0@,System.Func{``0,``0})"/>.</summary>
            <typeparam name="T">Type of object to wrap.</typeparam>
        </member>
        <member name="P:DryIoc.Ref`1.Value">
            <summary>Gets the wrapped value.</summary>
        </member>
        <member name="M:DryIoc.Ref`1.#ctor(`0)">
            <summary>Creates ref to object, optionally with initial value provided.</summary>
            <param name="initialValue">(optional) Initial value.</param>
        </member>
        <member name="M:DryIoc.Ref`1.Swap(System.Func{`0,`0})">
            <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="M:DryIoc.Ref.Swap``1(``0@,System.Func{``0,``0})"/> for details.</summary>
            <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
            <returns>Returns old object value the same way as <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/></returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:DryIoc.Ref`1.Swap(`0)">
            <summary>Just sets new value ignoring any intermingled changes.</summary>
            <param name="newValue"></param> <returns>old value</returns>
        </member>
        <member name="M:DryIoc.Ref`1.TrySwapIfStillCurrent(`0,`0)">
            <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
            <param name="currentValue"></param> <param name="newValue"></param>
            <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
            <example><c>[!CDATA[
            var value = SomeRef.Value;
            if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
                SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
            ]]</c></example>
        </member>
        <member name="T:DryIoc.Ref">
            <summary>Provides optimistic-concurrency consistent <see cref="M:DryIoc.Ref.Swap``1(``0@,System.Func{``0,``0})"/> operation.</summary>
        </member>
        <member name="M:DryIoc.Ref.Of``1(``0)">
            <summary>Factory for <see cref="T:DryIoc.Ref`1"/> with type of value inference.</summary>
            <typeparam name="T">Type of value to wrap.</typeparam>
            <param name="value">Initial value to wrap.</param>
            <returns>New ref.</returns>
        </member>
        <member name="M:DryIoc.Ref.NewRef``1(DryIoc.Ref{``0})">
            <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
            <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        </member>
        <member name="M:DryIoc.Ref.Swap``1(``0@,System.Func{``0,``0})">
            <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
            Second, it checks that original value is not changed. 
            If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
            <typeparam name="T">Type of value to swap.</typeparam>
            <param name="value">Reference to change to new value</param>
            <param name="getNewValue">Delegate to get value from old one.</param>
            <returns>Old/original value. By analogy with <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/>.</returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="T:DryIoc.KV`2">
            <summary>Immutable Key-Value pair. It is reference type (could be check for null), 
            which is different from System value type <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            In addition provides <see cref="M:DryIoc.KV`2.Equals(System.Object)"/> and <see cref="M:DryIoc.KV`2.GetHashCode"/> implementations.</summary>
            <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
        </member>
        <member name="F:DryIoc.KV`2.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:DryIoc.KV`2.Value">
            <summary>Value.</summary>
        </member>
        <member name="M:DryIoc.KV`2.#ctor(`0,`1)">
            <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
            <param name="key">key.</param><param name="value">value.</param>
        </member>
        <member name="M:DryIoc.KV`2.ToString">
            <summary>Creates nice string view.</summary><returns>String representation.</returns>
        </member>
        <member name="M:DryIoc.KV`2.Equals(System.Object)">
            <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
            <param name="obj">Object to check equality with.</param> <returns>True if equal.</returns>
        </member>
        <member name="M:DryIoc.KV`2.GetHashCode">
            <summary>Combines key and value hash code. R# generated default implementation.</summary>
            <returns>Combined hash code for key-value.</returns>
        </member>
        <member name="T:DryIoc.Update`1">
            <summary>Delegate for changing value from old one to some new based on provided new value.</summary>
            <typeparam name="V">Type of values.</typeparam>
            <param name="oldValue">Existing value.</param>
            <param name="newValue">New value passed to Update.. method.</param>
            <returns>Changed value.</returns>
        </member>
        <member name="T:DryIoc.ImTreeMapIntToObj">
            <summary>Simple immutable AVL tree with integer keys and object values.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Value">
            <summary>Value.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Left">
            <summary>Left sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Right">
            <summary>Right sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMapIntToObj.Height">
            <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="P:DryIoc.ImTreeMapIntToObj.IsEmpty">
            <summary>Returns true is tree is empty.</summary>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.AddOrUpdate(System.Int32,System.Object)">
            <summary>Returns new tree with added or updated value for specified key.</summary>
            <param name="key"></param> <param name="value"></param>
            <returns>New tree.</returns>
        </member>
        <member name="T:DryIoc.ImTreeMapIntToObj.UpdateValue">
            <summary>Delegate to calculate new value from and old and a new value.</summary>
            <param name="oldValue">Old</param> <param name="newValue">New</param> <returns>Calculated result.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.AddOrUpdate(System.Int32,System.Object,DryIoc.ImTreeMapIntToObj.UpdateValue)">
            <summary>Returns new tree with added or updated value for specified key.</summary>
            <param name="key">Key</param> <param name="value">Value</param>
            <param name="updateValue">(optional) Delegate to calculate new value from and old and a new value.</param>
            <returns>New tree.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.Update(System.Int32,System.Object)">
            <summary>Returns new tree with updated value for the key, Or the same tree if key was not found.</summary>
            <param name="key"></param> <param name="value"></param>
            <returns>New tree if key is found, or the same tree otherwise.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.GetValueOrDefault(System.Int32)">
            <summary>Get value for found key or null otherwise.</summary>
            <param name="key"></param> <returns>Found value or null.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMapIntToObj.Enumerate">
            <summary>Returns all sub-trees enumerated from left to right.</summary> 
            <returns>Enumerated sub-trees or empty if tree is empty.</returns>
        </member>
        <member name="T:DryIoc.ImTreeMap`2">
            <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree where actual node key is hash code of <typeparamref name="K"/>.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Key">
            <summary>Key of type K that should support <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Value">
            <summary>Value of any type V.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Hash">
            <summary>Calculated key hash.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Conflicts">
            <summary>In case of <see cref="F:DryIoc.ImTreeMap`2.Hash"/> conflicts for different keys contains conflicted keys with their values.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Left">
            <summary>Left sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Right">
            <summary>Right sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:DryIoc.ImTreeMap`2.Height">
            <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="P:DryIoc.ImTreeMap`2.IsEmpty">
            <summary>Returns true if tree is empty.</summary>
        </member>
        <member name="M:DryIoc.ImTreeMap`2.AddOrUpdate(`0,`1,DryIoc.Update{`1})">
            <summary>Returns new tree with added key-value. If value with the same key is exist, then
            if <paramref name="update"/> is not specified: then existing value will be replaced by <paramref name="value"/>;
            if <paramref name="update"/> is specified: then update delegate will decide what value to keep.</summary>
            <param name="key">Key to add.</param><param name="value">Value to add.</param>
            <param name="update">(optional) Delegate to decide what value to keep: old or new one.</param>
            <returns>New tree with added or updated key-value.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMap`2.Update(`0,`1,DryIoc.Update{`1})">
            <summary>Looks for <paramref name="key"/> and replaces its value with new <paramref name="value"/>, or 
            runs custom update handler (<paramref name="update"/>) with old and new value to get the updated result.</summary>
            <param name="key">Key to look for.</param>
            <param name="value">New value to replace key value with.</param>
            <param name="update">(optional) Delegate for custom update logic, it gets old and new <paramref name="value"/>
            as inputs and should return updated value as output.</param>
            <returns>New tree with updated value or the SAME tree if no key found.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMap`2.GetValueOrDefault(`0,`1)">
            <summary>Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.</summary>
            <param name="key">Key to look for.</param> <param name="defaultValue">(optional) Value to return if key is not found.</param>
            <returns>Found value or <paramref name="defaultValue"/>.</returns>
        </member>
        <member name="M:DryIoc.ImTreeMap`2.Enumerate">
            <summary>Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up (~20% faster than stack).</summary>
            <returns>Sequence of enumerated key value pairs.</returns>
        </member>
    </members>
</doc>
